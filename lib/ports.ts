import AsyncStorage from '@react-native-async-storage/async-storage';

export type PortEntry = {
  name: string;
  country?: string;
  regionCode?: string; // State/Province code, e.g., AK, WA, BC
  lat: number;
  lng: number;
  aliases?: string[];
  source?: 'curated' | 'cache' | 'online';
  // Classification
  kind?: 'cruise-terminal' | 'port' | 'harbor' | 'ferry-terminal' | 'pier' | 'marina' | 'other';
  isCruise?: boolean; // explicitly a cruise port/terminal
};

const PORTS_CACHE_KEY = 'ports_cache_v1';

// Load curated cruise ports from JSON (generated by scripts/fetch-cruise-ports.mjs), with fallback to a small inline seed
let curatedJson: any[] | undefined;
try {
  curatedJson = require('../assets/data/ports.curated.json');
} catch {
  curatedJson = undefined;
}
const curatedFallback: PortEntry[] = [
  { name: 'Seattle', country: 'US', regionCode: 'WA', lat: 47.6062, lng: -122.3321, aliases: ['Pier 91', 'Pier 66', 'Port of Seattle'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Vancouver', country: 'CA', regionCode: 'BC', lat: 49.2827, lng: -123.1207, aliases: ['Canada Place', 'Port of Vancouver'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Ketchikan', country: 'US', regionCode: 'AK', lat: 55.3422, lng: -131.6461, aliases: ['Ketchikan Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Juneau', country: 'US', regionCode: 'AK', lat: 58.3019, lng: -134.4197, aliases: ['Juneau Cruise Ship Terminal', 'Juneau, AK', 'Juneau, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Skagway', country: 'US', regionCode: 'AK', lat: 59.4583, lng: -135.3139, aliases: ['Skagway Cruise Dock', 'Skagway, AK', 'Skagway, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Sitka', country: 'US', regionCode: 'AK', lat: 57.0531, lng: -135.3300, aliases: ['Sitka, AK', 'Sitka Alaska', 'Sitka Sound Cruise Terminal'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Icy Strait Point', country: 'US', regionCode: 'AK', lat: 58.2881, lng: -135.4974, aliases: ['Hoonah', 'Hoonah, AK', 'Icy Strait'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Haines', country: 'US', regionCode: 'AK', lat: 59.2358, lng: -135.4450, aliases: ['Haines, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Whittier', country: 'US', regionCode: 'AK', lat: 60.7736, lng: -148.6847, aliases: ['Whittier, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Seward', country: 'US', regionCode: 'AK', lat: 60.1042, lng: -149.4422, aliases: ['Seward, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Victoria', country: 'CA', regionCode: 'BC', lat: 48.4284, lng: -123.3656, aliases: ['Victoria, BC', 'Ogden Point'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Miami', country: 'US', regionCode: 'FL', lat: 25.7743, lng: -80.1903, aliases: ['PortMiami', 'Miami Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Port Canaveral', country: 'US', regionCode: 'FL', lat: 28.4101, lng: -80.6188, aliases: ['Cape Canaveral', 'Canaveral Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Nassau', country: 'BS', lat: 25.0478, lng: -77.3554, aliases: ['Nassau Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Cozumel', country: 'MX', lat: 20.4230, lng: -86.9223, aliases: ['Cozumel Cruise Port', 'Puerto Maya', 'International Pier'], source: 'curated', kind: 'port', isCruise: true },
];
const curatedPorts: PortEntry[] = Array.isArray(curatedJson) && curatedJson.length > 0 ? curatedJson as PortEntry[] : curatedFallback;

export async function loadPortsCache(): Promise<PortEntry[]> {
  try {
    const raw = await AsyncStorage.getItem(PORTS_CACHE_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw) as PortEntry[];
    return Array.isArray(arr) ? arr : [];
  } catch {
    return [];
  }
}

async function savePortsCache(entries: PortEntry[]): Promise<void> {
  try { await AsyncStorage.setItem(PORTS_CACHE_KEY, JSON.stringify(entries)); } catch {}
}

export async function upsertCachedPort(entry: PortEntry): Promise<void> {
  const list = await loadPortsCache();
  const idx = list.findIndex(p => normalize(p.name) === normalize(entry.name));
  if (idx >= 0) list[idx] = { ...entry, source: 'cache' };
  else list.push({ ...entry, source: 'cache' });
  await savePortsCache(list);
}

function normalize(s: string): string {
  return s.trim().toLowerCase();
}

function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  if (m === 0) return n;
  if (n === 0) return m;
  const dp = new Array(n + 1);
  for (let j = 0; j <= n; j++) dp[j] = j;
  for (let i = 1; i <= m; i++) {
    let prev = i - 1;
    dp[0] = i;
    for (let j = 1; j <= n; j++) {
      const temp = dp[j];
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
      prev = temp;
    }
  }
  return dp[n];
}

function scoreName(query: string, candidate: string): number {
  const q = normalize(query);
  const c = normalize(candidate);
  if (!q || !c) return 0;
  if (c === q) return 1.0;
  if (c.startsWith(q)) return 0.95;
  if (c.includes(q)) return 0.85;
  const dist = levenshtein(q, c);
  const maxLen = Math.max(q.length, c.length) || 1;
  const sim = 1 - dist / maxLen; // 0..1
  return Math.max(0, sim * 0.8);
}

export function searchPorts(query: string, cache: PortEntry[], limit = 10): PortEntry[] {
  if (!query.trim()) return [];
  const pool = [...cache, ...curatedPorts];
  const isPorty = (s: string) => /\b(port|harbour|harbor|seaport|ferry|terminal|cruise|pier|dock|quay|marina)\b/i.test(s);
  const scored = pool.map(p => {
    const base = scoreName(query, p.name);
    const aliasScore = Math.max(0, ...(p.aliases || []).map(a => scoreName(query, a)));
    const raw = Math.max(base, aliasScore);
    // Consider it a port suggestion only if it's flagged cruise or looks port-like
    const porty = (p.isCruise === true) || isPorty(p.name) || (p.aliases || []).some(a => isPorty(a));
    const bonus = porty ? 0.1 : 0; // small boost
    return { p, s: Math.min(1, raw + bonus), porty };
  }).filter(x => x.porty && x.s >= 0.5); // only port-like or explicitly cruise
  scored.sort((a, b) => (Number(b.porty) - Number(a.porty)) || (b.s - a.s));
  const dedup = new Map<string, PortEntry>();
  for (const { p, s, porty } of scored) {
    const key = normalize(p.name);
    const existing = dedup.get(key);
    if (!existing) {
      dedup.set(key, p);
    } else {
      // Prefer entry with regionCode or country, then porty, then higher score
      const existingRich = (existing.regionCode ? 1 : 0) + (existing.country ? 1 : 0);
      const candidateRich = (p.regionCode ? 1 : 0) + (p.country ? 1 : 0);
      const existingPorty = /\b(port|harbour|harbor|seaport|ferry|terminal|cruise|pier)\b/i.test(existing.name);
      if (
        candidateRich > existingRich ||
        (candidateRich === existingRich && (Number(porty) > Number(existingPorty))) ||
        (candidateRich === existingRich && Number(porty) === Number(existingPorty) && s > scoreName(query, existing.name))
      ) {
        dedup.set(key, p);
      }
    }
    if (dedup.size >= limit) break;
  }
  return Array.from(dedup.values());
}

export function resolvePortByName(name: string, cache: PortEntry[]): PortEntry | undefined {
  const q = name.trim();
  if (!q) return undefined;
  // 1) Try direct fuzzy search
  const hits = searchPorts(q, cache, 1);
  if (hits[0]) return hits[0];

  // 2) If the query contains qualifiers like "City, ST, CC", try the primary token before the first comma
  const primary = q.split(',')[0]?.trim();
  if (primary && primary.length >= 2 && primary.toLowerCase() !== q.toLowerCase()) {
    const normPrimary = normalize(primary);

    // 2a) Exact name match in cache
    const exactCache = cache.find(p => normalize(p.name) === normPrimary);
    if (exactCache) return exactCache;

    // 2b) Exact name match in curated
    const exactCurated = curatedPorts.find(p => normalize(p.name) === normPrimary);
    if (exactCurated) return exactCurated;

    // 2c) Alias exact match across cache + curated
    const pool = [...cache, ...curatedPorts];
    const aliasExact = pool.find(p => (p.aliases || []).some(a => normalize(a) === normPrimary));
    if (aliasExact) return aliasExact;

    // 2d) Fuzzy search on the primary token
    const hitsPrimary = searchPorts(primary, cache, 1);
    if (hitsPrimary[0]) return hitsPrimary[0];

    // 2e) Fuzzy with port-like variants to boost likelihood
    const variants = [`${primary} cruise port`, `${primary} port`];
    for (const v of variants) {
      const hv = searchPorts(v, cache, 1);
      if (hv[0]) return hv[0];
    }
  }

  return undefined;
}

export function getCuratedPorts(): PortEntry[] {
  return curatedPorts.slice();
}

// Basic fuzzy matcher: true if similarity is above threshold using same scoring as searchPorts
export function fuzzyMatch(query: string, candidate?: string | null, minScore = 0.7): boolean {
  if (!candidate) return false;
  return scoreName(query, candidate) >= minScore;
}

// Online geocoding fallback using OpenStreetMap Nominatim
export async function searchPortsOnline(query: string, limit = 5): Promise<PortEntry[]> {
  const q = query.trim();
  if (!q) return [];
  try {
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&addressdetails=1&limit=${limit}`;
    const res = await fetch(url, {
      headers: {
        'User-Agent': 'cruise-journal-pro/1.0',
        'Accept-Language': 'en',
      },
    } as any);
    const data = await res.json();
    if (!Array.isArray(data)) return [];
    const out: { e: PortEntry; s: number; porty: boolean }[] = [];
    for (const it of data) {
      const name: string = it?.name || it?.display_name?.split(',')[0] || '';
      const lat = parseFloat(it?.lat);
      const lng = parseFloat(it?.lon);
      const cc: string | undefined = it?.address?.country_code ? String(it.address.country_code).toUpperCase() : undefined;
      const regionCode = deriveRegionCode(it?.address);
      if (!name || !isFinite(lat) || !isFinite(lng)) continue;
      // Restrict to likely port/cruise features only (no land-locked cities)
      const typ = String(it?.type || '');
      const cls = String(it?.class || '');
      const nameLower = name.toLowerCase();
      const isLikelyPortType = /harbour|harbor|port|seaport|ferry_terminal|ferry|pier|dock|quay|marina/i.test(typ) || /waterway|amenity|man_made/i.test(cls);
      const hasCruiseHint = /cruise|terminal|pier|portmiami|canada place|ogden point/i.test(nameLower);
      const isLikelyPort = isLikelyPortType || /harbour|harbor|port|pier|dock|quay/i.test(nameLower);
      if (!isLikelyPort) continue; // skip non-porty results entirely
      const s = scoreName(q, name);
      const isCruise = hasCruiseHint;
      const kind: PortEntry['kind'] = hasCruiseHint ? 'cruise-terminal' : (
        /ferry/i.test(typ) ? 'ferry-terminal' : (/harbour|harbor|port|seaport/i.test(typ) ? 'port' : (/pier|dock|quay/i.test(typ) ? 'pier' : (/marina/i.test(typ) ? 'marina' : 'other')))
      );
      out.push({ e: { name, country: cc, regionCode, lat, lng, source: 'online', kind, isCruise }, s, porty: true });
    }
    // Sort: prefer likely ports, then by score
    out.sort((a, b) => (Number((b.e.isCruise ? 1 : 0) - (a.e.isCruise ? 1 : 0))) || (b.s - a.s));
    // Deduplicate by name+country+region
    const seen = new Set<string>();
    const dedup: PortEntry[] = [];
    for (const { e: p } of out) {
      const key = `${normalize(p.name)}|${p.country || ''}|${p.regionCode || ''}`;
      if (!seen.has(key)) { seen.add(key); dedup.push(p); }
      if (dedup.length >= limit) break;
    }
    return dedup;
  } catch {
    return [];
  }
}

// Best-effort region code extraction from Nominatim address for US/CA
function deriveRegionCode(address: any): string | undefined {
  if (!address) return undefined;
  // Prefer provided state_code if present
  if (address.state_code && typeof address.state_code === 'string') {
    const code = address.state_code.toUpperCase();
    if (code.length <= 3) return code;
  }
  const stateName: string | undefined = address.state || address.region || undefined;
  const cc: string | undefined = address.country_code ? String(address.country_code).toUpperCase() : undefined;
  if (!stateName || !cc) return undefined;
  const name = stateName.toLowerCase();
  if (cc === 'US') {
    const us: Record<string, string> = {
      'alaska': 'AK', 'washington': 'WA', 'florida': 'FL', 'california': 'CA', 'new york': 'NY', 'texas': 'TX',
    };
    return us[name];
  }
  if (cc === 'CA') {
    const ca: Record<string, string> = {
      'british columbia': 'BC', 'alberta': 'AB', 'ontario': 'ON', 'quebec': 'QC', 'nova scotia': 'NS',
    };
    return ca[name];
  }
  return undefined;
}
