/**
 * Factory helpers for type-safe PortEntry creation.
 */
/**
 * Port resolution and cache flow:
 *
 * 1. User query is sanitized (e.g., 'History of the Port of X' → 'X').
 * 2. Resolution order: curated → cache → master → online (Google/OSM).
 * 3. Online results are only persisted if fuzzy match ≥ threshold (see PORTS_CACHE_CONFIG).
 * 4. Cache is capped by TTL (90d) and LRU (max entries).
 * 5. All cache operations are via PortsCache class.
 *
 * See PortsCache for details on load/save/upsert/evict.
 */
import { Platform } from 'react-native';
import { PortsCache } from './portsCache';

/**
 * Function makeCuratedPort: TODO describe purpose and usage.
 * @param {any} props - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * makeCuratedPort tags a PortEntry as coming from the curated dataset.
 */
export function makeCuratedPort(props: Omit<PortEntry, 'source'>): PortEntry {
  return { ...props, source: 'curated' };
}
/**
 * Function makeCachePort: TODO describe purpose and usage.
 * @param {any} props - TODO: describe
 * @param {any} meta - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * makeCachePort creates a cached PortEntry with persistence/timestamps metadata.
 */
export function makeCachePort(props: Omit<PortEntry, 'source' | 'savedAt' | 'lastAccessed' | 'originalQuery'>, meta?: { originalQuery?: string }): PortEntry {
  const now = Date.now();
  return { ...props, source: 'cache', savedAt: now, lastAccessed: now, originalQuery: meta?.originalQuery };
}
/**
 * Function makeOnlinePort: TODO describe purpose and usage.
 * @param {any} props - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * makeOnlinePort tags a PortEntry as fetched online (non-persistent until persisted).
 */
export function makeOnlinePort(props: Omit<PortEntry, 'source'>): PortEntry {
  return { ...props, source: 'online' };
}
/**
 * Function makeMasterPort: TODO describe purpose and usage.
 * @param {any} props - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * makeMasterPort tags a PortEntry as part of the bundled master dataset.
 */
export function makeMasterPort(props: Omit<PortEntry, 'source'>): PortEntry {
  return { ...props, source: 'master' };
}

export type PortEntry = {
  name: string;
  country?: string;
  regionCode?: string; // State/Province code, e.g., AK, WA, BC
  lat: number;
  lng: number;
  aliases?: string[];
  source?: 'curated' | 'cache' | 'online' | 'master';
  // metadata for cached entries
  originalQuery?: string; // the original search query that produced this cached entry
  savedAt?: number; // epoch ms when this entry was persisted
  lastAccessed?: number; // epoch ms of last read/access for LRU
  // Classification
  kind?: 'cruise-terminal' | 'port' | 'harbor' | 'ferry-terminal' | 'pier' | 'marina' | 'other';
  isCruise?: boolean; // explicitly a cruise port/terminal
};


export const PORTS_CACHE_CONFIG = {
  CACHE_KEY: 'ports_cache_v1',
  MAX_ENTRIES: 1500,
  TTL_MS: 90 * 24 * 60 * 60 * 1000, // 90 days
  PERSIST_FUZZY_THRESHOLD: 0.7,
};

const PORTS_CACHE_KEY = PORTS_CACHE_CONFIG.CACHE_KEY;
const MAX_PORT_CACHE_ENTRIES = PORTS_CACHE_CONFIG.MAX_ENTRIES;
const CACHE_TTL_MS = PORTS_CACHE_CONFIG.TTL_MS;
const PERSIST_FUZZY_THRESHOLD = PORTS_CACHE_CONFIG.PERSIST_FUZZY_THRESHOLD;

/**
 * Function debugLog: TODO describe purpose and usage.
 * @param {any} args - TODO: describe
 * @returns {any} TODO: describe
 */
function debugLog(...args: any[]) {
  try {
    if ((global as any).__DEV__ && console && console.debug) console.debug(...args);
  } catch {}
}

// Load curated cruise ports from JSON (generated by scripts/fetch-cruise-ports.mjs), with fallback to a small inline seed
let curatedJson: any[] | undefined;
try {
  curatedJson = require('../assets/data/ports.curated.json');
} catch {
  curatedJson = undefined;
}
const curatedFallback: PortEntry[] = [
  { name: 'Seattle', country: 'US', regionCode: 'WA', lat: 47.6062, lng: -122.3321, aliases: ['Pier 91', 'Pier 66', 'Port of Seattle'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Vancouver', country: 'CA', regionCode: 'BC', lat: 49.2827, lng: -123.1207, aliases: ['Canada Place', 'Port of Vancouver'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Ketchikan', country: 'US', regionCode: 'AK', lat: 55.3422, lng: -131.6461, aliases: ['Ketchikan Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Juneau', country: 'US', regionCode: 'AK', lat: 58.3019, lng: -134.4197, aliases: ['Juneau Cruise Ship Terminal', 'Juneau, AK', 'Juneau, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Skagway', country: 'US', regionCode: 'AK', lat: 59.4583, lng: -135.3139, aliases: ['Skagway Cruise Dock', 'Skagway, AK', 'Skagway, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Sitka', country: 'US', regionCode: 'AK', lat: 57.0531, lng: -135.3300, aliases: ['Sitka, AK', 'Sitka Alaska', 'Sitka Sound Cruise Terminal'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Icy Strait Point', country: 'US', regionCode: 'AK', lat: 58.2881, lng: -135.4974, aliases: ['Hoonah', 'Hoonah, AK', 'Icy Strait'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Haines', country: 'US', regionCode: 'AK', lat: 59.2358, lng: -135.4450, aliases: ['Haines, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Whittier', country: 'US', regionCode: 'AK', lat: 60.7736, lng: -148.6847, aliases: ['Whittier, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Seward', country: 'US', regionCode: 'AK', lat: 60.1042, lng: -149.4422, aliases: ['Seward, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Victoria', country: 'CA', regionCode: 'BC', lat: 48.4284, lng: -123.3656, aliases: ['Victoria, BC', 'Ogden Point'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Miami', country: 'US', regionCode: 'FL', lat: 25.7743, lng: -80.1903, aliases: ['PortMiami', 'Miami Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Port Canaveral', country: 'US', regionCode: 'FL', lat: 28.4101, lng: -80.6188, aliases: ['Cape Canaveral', 'Canaveral Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Nassau', country: 'BS', lat: 25.0478, lng: -77.3554, aliases: ['Nassau Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Cozumel', country: 'MX', lat: 20.4230, lng: -86.9223, aliases: ['Cozumel Cruise Port', 'Puerto Maya', 'International Pier'], source: 'curated', kind: 'port', isCruise: true },
  // Hawaii (added to ensure availability even if external JSON fails to load)
  { name: 'Honolulu', country: 'US', regionCode: 'HI', lat: 21.3069, lng: -157.8665, aliases: ['Honolulu Harbor', 'Honolulu, HI'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Hilo', country: 'US', regionCode: 'HI', lat: 19.7297, lng: -155.0900, aliases: ['Hilo, HI', 'Port of Hilo'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Kona', country: 'US', regionCode: 'HI', lat: 19.6397, lng: -155.9969, aliases: ['Kailua-Kona', 'Kona Tender'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Lahaina', country: 'US', regionCode: 'HI', lat: 20.8783, lng: -156.6825, aliases: ['Lahaina Tender'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Kahului', country: 'US', regionCode: 'HI', lat: 20.8947, lng: -156.4700, aliases: ['Kahului Harbor', 'Maui'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Nawiliwili', country: 'US', regionCode: 'HI', lat: 21.9560, lng: -159.3560, aliases: ['Kauai', 'Nawiliwili Harbor'], source: 'curated', kind: 'port', isCruise: true },
];
const curatedPorts: PortEntry[] = Array.isArray(curatedJson) && curatedJson.length > 0 ? curatedJson as PortEntry[] : curatedFallback;

// -------- Master Ports Dataset (large) --------
let masterPortsLoaded = false;
let masterPorts: PortEntry[] = [];
/**
 * Function loadMasterPorts: TODO describe purpose and usage.
 * @returns {any} TODO: describe
 */
async function loadMasterPorts(): Promise<PortEntry[]> {
  if (masterPortsLoaded) return masterPorts;
  try {
    // Dynamically import the large JSON so it doesn't inflate initial bundle
    // Using require inside try so web bundlers can tree-shake if unused
    const raw: any[] = require('../cruise_ports_master.json');
  masterPorts = (raw || [])
      .filter(r => r && (r.port_name || r.city))
      .map(r => {
        const name: string = r.port_name || r.city || '';
        const lat = parseFloat(r.latitude);
        const lng = parseFloat(r.longitude);
        return {
          name: name,
          country: r.country_or_territory || undefined,
          regionCode: r.region || undefined,
          lat: isFinite(lat) ? lat : 0,
          lng: isFinite(lng) ? lng : 0,
      source: 'master',
          kind: /terminal|cruise/i.test(name) ? 'cruise-terminal' : 'port',
          isCruise: /cruise|terminal/i.test(name)
        } as PortEntry;
      })
      .filter(p => p.name && p.lat !== 0 && p.lng !== 0);
  } catch {
    masterPorts = [];
  } finally {
    masterPortsLoaded = true;
  }
  return masterPorts;
}

// Persist online-fetched ports (Google / Nominatim) into local cache & in-memory master list
/**
 * Function persistOnlinePorts: TODO describe purpose and usage.
 * @param {any} fetched - TODO: describe
 * @param {any} query - TODO: describe
 * @returns {any} TODO: describe
 */
async function persistOnlinePorts(fetched: PortEntry[], query?: string) {
  if (!fetched || fetched.length === 0) return;
  try {
  debugLog(`[ports] persistOnlinePorts: candidate fetched entries=${fetched.length} for query='${query || ''}'`);
  const cache = await PortsCache.load();
    const byName = new Map(cache.map(p => [normalize(p.name), p]));
    let mutated = false;
    for (const p of fetched) {
      if (!p.name || !isFinite(p.lat) || !isFinite(p.lng)) continue;
      // If we have an original query, ensure the fetched name reasonably matches it before persisting
      if (query && !fuzzyMatch(query, p.name, PERSIST_FUZZY_THRESHOLD)) {
        debugLog(`[ports] persistOnlinePorts: skipping persist for '${p.name}' (no fuzzy match to '${query}')`);
        // still add to masterPorts runtime set for immediate availability, but don't save to persistent cache
        const existingMaster = masterPorts.find(mp => normalize(mp.name) === normalize(p.name));
        if (!existingMaster) masterPorts.push({ ...p, source: p.source || 'online' });
        continue;
      }
      const key = normalize(p.name);
      if (!byName.has(key)) {
        const now = Date.now();
        const entry: PortEntry = { ...p, source: 'cache', originalQuery: query, savedAt: now, lastAccessed: now };
        cache.push(entry);
        byName.set(key, entry);
        mutated = true;
  debugLog(`[ports] persistOnlinePorts: persisted '${p.name}' for query='${query || ''}'`);
      }
      // also add to masterPorts runtime set for immediate availability
      const existingMaster = masterPorts.find(mp => normalize(mp.name) === key);
      if (!existingMaster) masterPorts.push({ ...p, source: p.source || 'online' });
    }
    if (mutated) {
      // Trim cache if we've exceeded the soft cap (oldest first since we append new entries at end)
      if (cache.length > MAX_PORT_CACHE_ENTRIES) {
        const overflow = cache.length - MAX_PORT_CACHE_ENTRIES;
        cache.splice(0, overflow);
      }
  await PortsCache.save(cache);
    }
  } catch {

    // ignore persistence errors silently
  }
}


/**
 * Function clearPortsCache: TODO describe purpose and usage.
 * @returns {any} TODO: describe
 */
/**
 * clearPortsCache wipes the persisted ports cache from AsyncStorage.
 */
export async function clearPortsCache(): Promise<void> {
  await PortsCache.clear();
  debugLog('[ports] clearPortsCache: cleared AsyncStorage cache');
}

/**
 * Function upsertCachedPort: TODO describe purpose and usage.
 * @param {any} entry - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * upsertCachedPort inserts or updates a port entry in the local cache.
 */
export async function upsertCachedPort(entry: PortEntry): Promise<void> {
  await PortsCache.upsert(entry);
}

// Remove a cached port by name (case/diacritics-insensitive). Returns true if removed.
/**
 * Function removeCachedPortByName: TODO describe purpose and usage.
 * @param {any} name - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * removeCachedPortByName deletes a cached port matching the given name (case/diacritics-insensitive).
 * Returns true if a record was removed.
 */
export async function removeCachedPortByName(name: string): Promise<boolean> {
  const ok = await PortsCache.removeByName(name);
  if (ok) debugLog(`[ports] removeCachedPortByName: removed '${name}'`);
  return ok;
}

/**
 * Function stripDiacritics: TODO describe purpose and usage.
 * @param {any} s - TODO: describe
 * @returns {any} TODO: describe
 */
function stripDiacritics(s: string): string {
  try { return s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch { return s; }
}
/**
 * Function normalize: TODO describe purpose and usage.
 * @param {any} s - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * normalize lowercases and strips diacritics/whitespace from a string for fuzzy matching.
 */
export function normalize(s: string): string {
  return stripDiacritics(s).trim().toLowerCase();
}

// Try to clean up noisy user-supplied port strings like
// "History of the Port of Tianjin" -> "Tianjin"
/**
 * Function sanitizePortQuery: TODO describe purpose and usage.
 * @param {any} s - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * sanitizePortQuery removes common “port history” descriptors and parentheses from user input
 * to yield a cleaner place name for matching.
 */
export function sanitizePortQuery(s: string): string {
  if (!s) return s;
  let q = s.trim();
  // common leading descriptors to strip
  const patterns: RegExp[] = [
    /^history of the port of\s+(.+)$/i,
    /^history of the\s+(.+)$/i,
    /^history of\s+(.+)$/i,
    /^the port of\s+(.+)$/i,
    /^port of\s+(.+)$/i,
    /^port:\s*(.+)$/i,
    /^(.+)\s+-\s+history$/i,
  ];
  for (const p of patterns) {
    const m = q.match(p);
    if (m && m[1]) { q = m[1].trim(); break; }
  }
  // strip trailing parenthetical descriptors like "(history)" or "(museum)"
  q = q.replace(/\s*\((?:history|museum|port history)\)\s*$/i, '').trim();
  return q;
}

// Lightweight Jaro-Winkler for better short fuzzy matches (improves e.g. "cozuml" -> "Cozumel")
/**
 * Function jaroWinkler: TODO describe purpose and usage.
 * @param {any} a - TODO: describe
 * @param {any} b - TODO: describe
 * @returns {any} TODO: describe
 */
function jaroWinkler(a: string, b: string): number {
  if (a === b) return 1;
  const al = a.length, bl = b.length;
  if (!al || !bl) return 0;
  const matchDistance = Math.floor(Math.max(al, bl) / 2) - 1;
  const aMatches: boolean[] = new Array(al).fill(false);
  const bMatches: boolean[] = new Array(bl).fill(false);
  let matches = 0;
  for (let i = 0; i < al; i++) {
    const start = Math.max(0, i - matchDistance);
    const end = Math.min(i + matchDistance + 1, bl);
    for (let j = start; j < end; j++) {
      if (bMatches[j]) continue;
      if (a[i] !== b[j]) continue;
      aMatches[i] = true;
      bMatches[j] = true;
      matches++;
      break;
    }
  }
  if (!matches) return 0;
  let t = 0; // transpositions
  let k = 0;
  for (let i = 0; i < al; i++) {
    if (!aMatches[i]) continue;
    while (!bMatches[k]) k++;
    if (a[i] !== b[k]) t++;
    k++;
  }
  t /= 2;
  const m = matches;
  let jaro = (m / al + m / bl + (m - t) / m) / 3;
  // Winkler prefix boost
  let prefix = 0;
  for (let i = 0; i < Math.min(4, al, bl); i++) { if (a[i] === b[i]) prefix++; else break; }
  if (jaro > 0.7 && prefix) jaro = jaro + 0.1 * prefix * (1 - jaro);
  return jaro;
}

/**
 * Function levenshtein: TODO describe purpose and usage.
 * @param {any} a - TODO: describe
 * @param {any} b - TODO: describe
 * @returns {any} TODO: describe
 */
function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  if (m === 0) return n;
  if (n === 0) return m;
  const dp = new Array(n + 1);
  for (let j = 0; j <= n; j++) dp[j] = j;
  for (let i = 1; i <= m; i++) {
    let prev = i - 1;
    dp[0] = i;
    for (let j = 1; j <= n; j++) {
      const temp = dp[j];
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
      prev = temp;
    }
  }
  return dp[n];
}

/**
 * Function scoreName: TODO describe purpose and usage.
 * @param {any} query - TODO: describe
 * @param {any} candidate - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * scoreName computes a fuzzy similarity 0..1 between query and candidate using tokenized prefix
 * and Levenshtein/Jaro‑Winkler fallbacks. Heavily used by searchPorts.
 */
export function scoreName(query: string, candidate: string): number {
  const qRaw = normalize(query);
  const c = normalize(candidate);
  if (!qRaw || !c) return 0;
  if (c === qRaw) return 1.0;
  // Token scoring: sum best token matches normalized by token count
  const tokens = qRaw.split(/[^a-z0-9]+/).filter(Boolean);
  if (tokens.length === 0) return 0;
  let total = 0;
  for (const t of tokens) {
    if (!t) continue;
    if (c === t) { total += 1; continue; }
    if (c.startsWith(t)) { total += 0.95; continue; }
  // avoid accidental matches on very short tokens (e.g., 'hi' matching 'karachi')
  if (t.length >= 3 && c.includes(t)) { total += 0.85; continue; }
    // Levenshtein similarity fallback
    const dist = levenshtein(t, c);
    const maxLen = Math.max(t.length, c.length) || 1;
    let sim = 1 - dist / maxLen; // 0..1
    // If still low, try Jaro-Winkler which is strong for transpositions / typos
    if (sim < 0.75) {
      const jw = jaroWinkler(t, c);
      sim = Math.max(sim, jw * 0.9);
    }
    total += Math.max(0, sim * 0.8);
  }
  let score = total / tokens.length;
  return Math.min(1, score);
}

// Optional: external callers can feed recent port names (most-used) for a slight boost
/**
 * Function searchPorts: TODO describe purpose and usage.
 * @param {any} query - TODO: describe
 * @param {any} cache - TODO: describe
 * @param {any} limit - TODO: describe
 * @param {any} recentNames - TODO: describe
 * @param {any} includeMaster - TODO: describe
 * @param {any} includeCurated - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * searchPorts searches curated/master and cache (configurable) for port‑like entries matching a query.
 * Applies port‑specific heuristics (aliases, country/region hints) and returns top N unique matches.
 */
export function searchPorts(query: string, cache: PortEntry[], limit = 10, recentNames?: string[], includeMaster = true, includeCurated = true): PortEntry[] {
  if (!query.trim()) return [];
  const recentSet = new Set((recentNames || []).map(n => normalize(n)).slice(0, 24));
  // Compose pool per flags. For geolocation from map interactions we can exclude curated.
  const curatedPart = includeCurated ? curatedPorts : [] as PortEntry[];
  const pool = includeMaster ? [...curatedPart, ...cache, ...masterPorts] : [...curatedPart, ...cache];
  const short = query.trim().length <= 3; // for short prefixes, relax constraints
  const isPorty = /**
   * Function isPorty: TODO describe purpose and usage.
   * @param {string} s - TODO: describe
   * @returns {boolean} TODO: describe
   */
  (s: string) => /\b(port|harbour|harbor|seaport|ferry|terminal|cruise|pier|dock|quay|marina)\b/i.test(s);
  const qNorm = normalize(query);
  const scored = pool.map(p => {
    const base = scoreName(qNorm, p.name);
    const aliasScore = Math.max(0, ...(p.aliases || []).map(a => scoreName(qNorm, a)));
    let raw = Math.max(base, aliasScore);
    const porty = (p.isCruise === true) || isPorty(p.name) || (p.aliases || []).some(a => isPorty(a));
    if (porty) raw += 0.08;
    if (recentSet.has(normalize(p.name))) raw += 0.04; // small recency boost
    // Country / region code inclusion if user typed them
    const regionHint = /,\s*([A-Za-z]{2})(?:,|$)/.exec(query);
    if (regionHint && (p.regionCode || p.country)) {
      const code = regionHint[1].toUpperCase();
      if (p.regionCode === code || p.country === code) raw += 0.05;
    }
    const startsWith = normalize(p.name).startsWith(qNorm) || (p.aliases || []).some(a => normalize(a).startsWith(qNorm));
    return { p, s: Math.min(1, raw), porty, startsWith };
  }).filter(x => {
    if (short) {
      // For very short queries, allow prefix matches even if not yet classified porty
      if (x.startsWith) return true;
    }
    return x.porty && x.s >= (short ? 0.30 : 0.45);
  });
  scored.sort((a, b) => (b.s - a.s));
  // Stable promote prefix matches for short queries
  if (short) {
    scored.sort((a, b) => (Number(b.startsWith) - Number(a.startsWith)) || (b.s - a.s));
  }
  const dedup = new Map<string, PortEntry>();
  for (const { p, s } of scored) {
    const key = normalize(p.name);
    const existing = dedup.get(key);
    if (!existing) {
      dedup.set(key, p);
    } else {
      const existingRich = (existing.regionCode ? 1 : 0) + (existing.country ? 1 : 0);
      const candidateRich = (p.regionCode ? 1 : 0) + (p.country ? 1 : 0);
      if (candidateRich > existingRich && s >= 0.5) {
        dedup.set(key, p);
      }
    }
    if (dedup.size >= limit) break;
  }
  return Array.from(dedup.values());
}

/**
 * resolvePortByName resolves a user‑typed name to a cached PortEntry using sanitization, exact/alias
 * matches and fuzzy search on the primary token (cache‑only). Does not hit the network.
 */
export function resolvePortByName(name: string, cache: PortEntry[]): PortEntry | undefined {
  const q = name.trim();
  if (!q) return undefined;
  const sanitized = sanitizePortQuery(q);
  if (sanitized !== q) {
    console.debug && console.debug(`[ports] resolvePortByName: sanitized '${q}' -> '${sanitized}'`);
  }
  // 1) Try direct fuzzy search on CACHE ONLY (exclude curated/master)
  const hits = searchPorts(sanitized, cache, 1, undefined, false, false);
  if (hits[0]) return hits[0];

  // 2) If the query contains qualifiers like "City, ST, CC", try the primary token before the first comma
  const primary = sanitized.split(',')[0]?.trim();
  if (primary && primary.length >= 2 && primary.toLowerCase() !== q.toLowerCase()) {
    const normPrimary = normalize(primary);

  // 2a) Exact name match in cache only
  const exactCache = cache.find(p => normalize(p.name) === normPrimary);
  if (exactCache) return exactCache;

  // 2c) Alias exact match within cache only
  const aliasExact = cache.find(p => (p.aliases || []).some(a => normalize(a) === normPrimary));
  if (aliasExact) {
    console.debug && console.debug(`[ports] resolvePortByName: '${q}' -> '${aliasExact.name}' (alias exact match)`);
    return aliasExact;
  }

  // 2d) Fuzzy search on the primary token (curated+cache-only to prefer authoritative matches)
  const hitsPrimary = searchPorts(primary, cache, 1, undefined, false, false);
    if (hitsPrimary[0]) return hitsPrimary[0];

    // 2e) Fuzzy with port-like variants to boost likelihood
    const variants = [`${primary} cruise port`, `${primary} port`];
    for (const v of variants) {
      const hv = searchPorts(v, cache, 1, undefined, false, false);
      if (hv[0]) {
        console.debug && console.debug(`[ports] resolvePortByName: '${q}' -> '${hv[0].name}' (variant '${v}')`);
        return hv[0];
      }
    }
  }

  return undefined;
}

/**
 * Function getCuratedPorts: TODO describe purpose and usage.
 * @returns {any} TODO: describe
 */
/**
 * getCuratedPorts returns a shallow copy of the bundled curated cruise ports list.
 */
export function getCuratedPorts(): PortEntry[] {
  return curatedPorts.slice();
}

// Basic fuzzy matcher: true if similarity is above threshold using same scoring as searchPorts
/**
 * Function fuzzyMatch: TODO describe purpose and usage.
 * @param {any} query - TODO: describe
 * @param {any} candidate - TODO: describe
 * @param {any} minScore - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * fuzzyMatch returns true if the candidate string is similar enough to the query for our purposes.
 */
export function fuzzyMatch(query: string, candidate?: string | null, minScore = 0.7): boolean {
  if (!candidate) return false;
  return scoreName(query, candidate) >= minScore;
}

// Online geocoding fallback using OpenStreetMap Nominatim
/**
 * Function searchPortsOnline: TODO describe purpose and usage.
 * @param {any} query - TODO: describe
 * @param {any} limit - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * searchPortsOnline queries MapTiler (if configured) and then OSM Nominatim for port‑like places.
 * Filters out airports/airfields/heliports and tries to retain cruise‑relevant results.
 */
export async function searchPortsOnline(query: string, limit = 5): Promise<PortEntry[]> {
  const q = query.trim();
  if (!q) return [];
  const results: PortEntry[] = [];
  const isEnglishLike = /**
   * Function isEnglishLike: TODO describe purpose and usage.
   * @param {string} label - TODO: describe
   * @returns {boolean} TODO: describe
   */
  (label: string) => !!label && !/[^\x00-\x7F]/.test(label) && /[A-Za-z]{2,}/.test(label);
  // Prefer MapTiler geocoding if configured (better availability than raw Nominatim)
  const maptilerKey = (Platform as any).OS ? (process.env.EXPO_PUBLIC_MAPTILER_KEY || '') : '';
  if (maptilerKey) {
    try {
      const url = `https://api.maptiler.com/geocoding/${encodeURIComponent(q)}.json?key=${maptilerKey}&limit=${limit}&language=en&types=poi,place,locality`;
      const res = await fetch(url);
      const data: any = await res.json();
      if (data && Array.isArray(data.features)) {
        for (const f of data.features) {
          const label: string = f.place_name || f.text || f.properties?.name || '';
          const coords = f.center || f.geometry?.coordinates;
          const lng = Array.isArray(coords) ? Number(coords[0]) : NaN;
          const lat = Array.isArray(coords) ? Number(coords[1]) : NaN;
          if (!label || !isFinite(lat) || !isFinite(lng) || !isEnglishLike(label)) continue;
          const lower = label.toLowerCase();
          // Explicitly exclude airports/airfields/heliports (avoid 'airport' matching 'port')
          if (/(airport|air\s?field|airfield|heliport|heli\s?port)/i.test(lower)) continue;
          // Keep only port-like results
          if (!/(harbour|harbor|\bport\b|seaport|ferry|terminal|cruise|pier|dock|quay|marina)/i.test(lower)) continue;
          results.push({ name: label, lat, lng, source: 'online', kind: /cruise|terminal/.test(lower) ? 'cruise-terminal' : 'port', isCruise: /cruise|terminal/.test(lower) });
          if (results.length >= limit) return results;
        }
      }
    } catch {}
  }
  // Fallback to OpenStreetMap Nominatim
  try {
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&addressdetails=1&limit=${limit}`;
    const res = await fetch(url, { headers: { 'User-Agent': 'portlist/1.0', 'Accept-Language': 'en' } } as any);
    const data = await res.json();
    if (!Array.isArray(data)) return results;
    for (const it of data) {
      const name: string = it?.name || it?.display_name?.split(',')[0] || '';
      const lat = parseFloat(it?.lat);
      const lng = parseFloat(it?.lon);
      const cc: string | undefined = it?.address?.country_code ? String(it.address.country_code).toUpperCase() : undefined;
      const regionCode = deriveRegionCode(it?.address);
      if (!name || !isFinite(lat) || !isFinite(lng) || !isEnglishLike(name)) continue;
      const typ = String(it?.type || '');
      const cls = String(it?.class || '');
      const nameLower = name.toLowerCase();
      // Exclude aeroway/airport-like results
      if (/aeroway/i.test(cls) || /airport|air\s?field|airfield|heliport|heli\s?port/i.test(nameLower)) continue;
      const isLikelyPortType = /harbour|harbor|port|seaport|ferry_terminal|ferry|pier|dock|quay|marina/i.test(typ) || /waterway|amenity|man_made/i.test(cls);
      const hasCruiseHint = /cruise|terminal|pier|portmiami|canada place|ogden point/i.test(nameLower);
      const isLikelyPort = isLikelyPortType || /harbour|harbor|\bport\b|pier|dock|quay/i.test(nameLower);
      if (!isLikelyPort) continue;
      results.push({ name, country: cc, regionCode, lat, lng, source: 'online', kind: hasCruiseHint ? 'cruise-terminal' : 'port', isCruise: hasCruiseHint });
      if (results.length >= limit) break;
    }
  } catch {}
  return results;
}

// Removed Google Places fallback — rely on curated/cache/master and OSM-based search only.

// Unified search: master+cache+curated first, then Nominatim
/**
 * Function unifiedPortSearch: TODO describe purpose and usage.
 * @param {any} query - TODO: describe
 * @param {any} cache - TODO: describe
 * @param {any} desired - TODO: describe
 * @returns {any} TODO: describe
 */
/**
 * unifiedPortSearch first searches curated/master/cache locally; if insufficient, augments results
 * with online geocoding and persists confident matches. Returns a deduped list up to `desired` items.
 */
export async function unifiedPortSearch(query: string, cache: PortEntry[], desired = 10): Promise<PortEntry[]> {
  await loadMasterPorts(); // ensure master dataset is loaded
  const local = searchPorts(query, cache, desired);
  if (local.length >= desired) return local.slice(0, desired);
  const seen = new Set(local.map(p => normalize(p.name)+ '|' + (p.country||'') + '|' + (p.regionCode||'')));
  const merged1 = [...local];
  const osm = await searchPortsOnline(query, Math.max(0, desired - merged1.length));
  if (osm.length) { persistOnlinePorts(osm, query).catch(()=>{}); }
  for (const o of osm) {
    const key = normalize(o.name)+'|'+(o.country||'')+'|'+(o.regionCode||'');
    if (!seen.has(key)) { merged1.push(o); seen.add(key); }
    if (merged1.length >= desired) break;
  }
  return merged1.slice(0, desired);
}

// Best-effort region code extraction from Nominatim address for US/CA
/**
 * Function deriveRegionCode: TODO describe purpose and usage.
 * @param {any} address - TODO: describe
 * @returns {any} TODO: describe
 */
function deriveRegionCode(address: any): string | undefined {
  if (!address) return undefined;
  // Prefer provided state_code if present
  if (address.state_code && typeof address.state_code === 'string') {
    const code = address.state_code.toUpperCase();
    if (code.length <= 3) return code;
  }
  const stateName: string | undefined = address.state || address.region || undefined;
  const cc: string | undefined = address.country_code ? String(address.country_code).toUpperCase() : undefined;
  if (!stateName || !cc) return undefined;
  const name = stateName.toLowerCase();
  if (cc === 'US') {
    const us: Record<string, string> = {
      'alaska': 'AK', 'washington': 'WA', 'florida': 'FL', 'california': 'CA', 'new york': 'NY', 'texas': 'TX',
    };
    return us[name];
  }
  if (cc === 'CA') {
    const ca: Record<string, string> = {
      'british columbia': 'BC', 'alberta': 'AB', 'ontario': 'ON', 'quebec': 'QC', 'nova scotia': 'NS',
    };
    return ca[name];
  }
  return undefined;
}
