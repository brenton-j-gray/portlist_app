import AsyncStorage from '@react-native-async-storage/async-storage';
import { Platform } from 'react-native';

export type PortEntry = {
  name: string;
  country?: string;
  regionCode?: string; // State/Province code, e.g., AK, WA, BC
  lat: number;
  lng: number;
  aliases?: string[];
  source?: 'curated' | 'cache' | 'online';
  // Classification
  kind?: 'cruise-terminal' | 'port' | 'harbor' | 'ferry-terminal' | 'pier' | 'marina' | 'other';
  isCruise?: boolean; // explicitly a cruise port/terminal
};

const PORTS_CACHE_KEY = 'ports_cache_v1';
// Soft cap for number of cached (network-fetched) port entries to avoid unbounded growth.
// Chosen to be reasonably high while keeping JSON size manageable for AsyncStorage.
const MAX_PORT_CACHE_ENTRIES = 1500;

// Load curated cruise ports from JSON (generated by scripts/fetch-cruise-ports.mjs), with fallback to a small inline seed
let curatedJson: any[] | undefined;
try {
  curatedJson = require('../assets/data/ports.curated.json');
} catch {
  curatedJson = undefined;
}
const curatedFallback: PortEntry[] = [
  { name: 'Seattle', country: 'US', regionCode: 'WA', lat: 47.6062, lng: -122.3321, aliases: ['Pier 91', 'Pier 66', 'Port of Seattle'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Vancouver', country: 'CA', regionCode: 'BC', lat: 49.2827, lng: -123.1207, aliases: ['Canada Place', 'Port of Vancouver'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Ketchikan', country: 'US', regionCode: 'AK', lat: 55.3422, lng: -131.6461, aliases: ['Ketchikan Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Juneau', country: 'US', regionCode: 'AK', lat: 58.3019, lng: -134.4197, aliases: ['Juneau Cruise Ship Terminal', 'Juneau, AK', 'Juneau, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Skagway', country: 'US', regionCode: 'AK', lat: 59.4583, lng: -135.3139, aliases: ['Skagway Cruise Dock', 'Skagway, AK', 'Skagway, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Sitka', country: 'US', regionCode: 'AK', lat: 57.0531, lng: -135.3300, aliases: ['Sitka, AK', 'Sitka Alaska', 'Sitka Sound Cruise Terminal'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Icy Strait Point', country: 'US', regionCode: 'AK', lat: 58.2881, lng: -135.4974, aliases: ['Hoonah', 'Hoonah, AK', 'Icy Strait'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Haines', country: 'US', regionCode: 'AK', lat: 59.2358, lng: -135.4450, aliases: ['Haines, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Whittier', country: 'US', regionCode: 'AK', lat: 60.7736, lng: -148.6847, aliases: ['Whittier, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Seward', country: 'US', regionCode: 'AK', lat: 60.1042, lng: -149.4422, aliases: ['Seward, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Victoria', country: 'CA', regionCode: 'BC', lat: 48.4284, lng: -123.3656, aliases: ['Victoria, BC', 'Ogden Point'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Miami', country: 'US', regionCode: 'FL', lat: 25.7743, lng: -80.1903, aliases: ['PortMiami', 'Miami Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Port Canaveral', country: 'US', regionCode: 'FL', lat: 28.4101, lng: -80.6188, aliases: ['Cape Canaveral', 'Canaveral Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Nassau', country: 'BS', lat: 25.0478, lng: -77.3554, aliases: ['Nassau Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Cozumel', country: 'MX', lat: 20.4230, lng: -86.9223, aliases: ['Cozumel Cruise Port', 'Puerto Maya', 'International Pier'], source: 'curated', kind: 'port', isCruise: true },
  // Hawaii (added to ensure availability even if external JSON fails to load)
  { name: 'Honolulu', country: 'US', regionCode: 'HI', lat: 21.3069, lng: -157.8665, aliases: ['Honolulu Harbor', 'Honolulu, HI'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Hilo', country: 'US', regionCode: 'HI', lat: 19.7297, lng: -155.0900, aliases: ['Hilo, HI', 'Port of Hilo'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Kona', country: 'US', regionCode: 'HI', lat: 19.6397, lng: -155.9969, aliases: ['Kailua-Kona', 'Kona Tender'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Lahaina', country: 'US', regionCode: 'HI', lat: 20.8783, lng: -156.6825, aliases: ['Lahaina Tender'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Kahului', country: 'US', regionCode: 'HI', lat: 20.8947, lng: -156.4700, aliases: ['Kahului Harbor', 'Maui'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Nawiliwili', country: 'US', regionCode: 'HI', lat: 21.9560, lng: -159.3560, aliases: ['Kauai', 'Nawiliwili Harbor'], source: 'curated', kind: 'port', isCruise: true },
];
const curatedPorts: PortEntry[] = Array.isArray(curatedJson) && curatedJson.length > 0 ? curatedJson as PortEntry[] : curatedFallback;

// -------- Master Ports Dataset (large) --------
let masterPortsLoaded = false;
let masterPorts: PortEntry[] = [];
async function loadMasterPorts(): Promise<PortEntry[]> {
  if (masterPortsLoaded) return masterPorts;
  try {
    // Dynamically import the large JSON so it doesn't inflate initial bundle
    // Using require inside try so web bundlers can tree-shake if unused
    const raw: any[] = require('../cruise_ports_master.json');
    masterPorts = (raw || [])
      .filter(r => r && (r.port_name || r.city))
      .map(r => {
        const name: string = r.port_name || r.city || '';
        const lat = parseFloat(r.latitude);
        const lng = parseFloat(r.longitude);
        return {
          name: name,
          country: r.country_or_territory || undefined,
          regionCode: r.region || undefined,
          lat: isFinite(lat) ? lat : 0,
          lng: isFinite(lng) ? lng : 0,
          source: 'curated',
          kind: /terminal|cruise/i.test(name) ? 'cruise-terminal' : 'port',
          isCruise: /cruise|terminal/i.test(name)
        } as PortEntry;
      })
      .filter(p => p.name && p.lat !== 0 && p.lng !== 0);
  } catch {
    masterPorts = [];
  } finally {
    masterPortsLoaded = true;
  }
  return masterPorts;
}

// Persist online-fetched ports (Google / Nominatim) into local cache & in-memory master list
async function persistOnlinePorts(fetched: PortEntry[]) {
  if (!fetched || fetched.length === 0) return;
  try {
    const cache = await loadPortsCache();
    const byName = new Map(cache.map(p => [normalize(p.name), p]));
    let mutated = false;
    for (const p of fetched) {
      if (!p.name || !isFinite(p.lat) || !isFinite(p.lng)) continue;
      const key = normalize(p.name);
      if (!byName.has(key)) {
        const entry: PortEntry = { ...p, source: 'cache' };
        cache.push(entry);
        byName.set(key, entry);
        mutated = true;
      }
      // also add to masterPorts runtime set for immediate availability
      const existingMaster = masterPorts.find(mp => normalize(mp.name) === key);
      if (!existingMaster) masterPorts.push({ ...p, source: p.source || 'online' });
    }
    if (mutated) {
      // Trim cache if we've exceeded the soft cap (oldest first since we append new entries at end)
      if (cache.length > MAX_PORT_CACHE_ENTRIES) {
        const overflow = cache.length - MAX_PORT_CACHE_ENTRIES;
        cache.splice(0, overflow);
      }
      await savePortsCache(cache);
    }
  } catch {
    // ignore persistence errors silently
  }
}

export async function loadPortsCache(): Promise<PortEntry[]> {
  try {
    const raw = await AsyncStorage.getItem(PORTS_CACHE_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw) as PortEntry[];
    return Array.isArray(arr) ? arr : [];
  } catch {
    return [];
  }
}

async function savePortsCache(entries: PortEntry[]): Promise<void> {
  try { await AsyncStorage.setItem(PORTS_CACHE_KEY, JSON.stringify(entries)); } catch {}
}

export async function upsertCachedPort(entry: PortEntry): Promise<void> {
  const list = await loadPortsCache();
  const idx = list.findIndex(p => normalize(p.name) === normalize(entry.name));
  if (idx >= 0) list[idx] = { ...entry, source: 'cache' };
  else list.push({ ...entry, source: 'cache' });
  await savePortsCache(list);
}

function stripDiacritics(s: string): string {
  try { return s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch { return s; }
}
function normalize(s: string): string {
  return stripDiacritics(s).trim().toLowerCase();
}

// Lightweight Jaro-Winkler for better short fuzzy matches (improves e.g. "cozuml" -> "Cozumel")
function jaroWinkler(a: string, b: string): number {
  if (a === b) return 1;
  const al = a.length, bl = b.length;
  if (!al || !bl) return 0;
  const matchDistance = Math.floor(Math.max(al, bl) / 2) - 1;
  const aMatches: boolean[] = new Array(al).fill(false);
  const bMatches: boolean[] = new Array(bl).fill(false);
  let matches = 0;
  for (let i = 0; i < al; i++) {
    const start = Math.max(0, i - matchDistance);
    const end = Math.min(i + matchDistance + 1, bl);
    for (let j = start; j < end; j++) {
      if (bMatches[j]) continue;
      if (a[i] !== b[j]) continue;
      aMatches[i] = true;
      bMatches[j] = true;
      matches++;
      break;
    }
  }
  if (!matches) return 0;
  let t = 0; // transpositions
  let k = 0;
  for (let i = 0; i < al; i++) {
    if (!aMatches[i]) continue;
    while (!bMatches[k]) k++;
    if (a[i] !== b[k]) t++;
    k++;
  }
  t /= 2;
  const m = matches;
  let jaro = (m / al + m / bl + (m - t) / m) / 3;
  // Winkler prefix boost
  let prefix = 0;
  for (let i = 0; i < Math.min(4, al, bl); i++) { if (a[i] === b[i]) prefix++; else break; }
  if (jaro > 0.7 && prefix) jaro = jaro + 0.1 * prefix * (1 - jaro);
  return jaro;
}

function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  if (m === 0) return n;
  if (n === 0) return m;
  const dp = new Array(n + 1);
  for (let j = 0; j <= n; j++) dp[j] = j;
  for (let i = 1; i <= m; i++) {
    let prev = i - 1;
    dp[0] = i;
    for (let j = 1; j <= n; j++) {
      const temp = dp[j];
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
      prev = temp;
    }
  }
  return dp[n];
}

function scoreName(query: string, candidate: string): number {
  const qRaw = normalize(query);
  const c = normalize(candidate);
  if (!qRaw || !c) return 0;
  if (c === qRaw) return 1.0;
  // Token scoring: sum best token matches normalized by token count
  const tokens = qRaw.split(/[^a-z0-9]+/).filter(Boolean);
  if (tokens.length === 0) return 0;
  let total = 0;
  for (const t of tokens) {
    if (!t) continue;
    if (c === t) { total += 1; continue; }
    if (c.startsWith(t)) { total += 0.95; continue; }
    if (c.includes(t)) { total += 0.85; continue; }
    // Levenshtein similarity fallback
    const dist = levenshtein(t, c);
    const maxLen = Math.max(t.length, c.length) || 1;
    let sim = 1 - dist / maxLen; // 0..1
    // If still low, try Jaro-Winkler which is strong for transpositions / typos
    if (sim < 0.75) {
      const jw = jaroWinkler(t, c);
      sim = Math.max(sim, jw * 0.9);
    }
    total += Math.max(0, sim * 0.8);
  }
  let score = total / tokens.length;
  // Boost if candidate ends with region/country patterns present in query
  const regionPattern = /\b([A-Z]{2})\b/; // simple two-letter code
  const regionMatch = query.match(regionPattern);
  if (regionMatch) {
    const code = regionMatch[1].toLowerCase();
    if (c.includes(code)) score += 0.05;
  }
  return Math.min(1, score);
}

// Optional: external callers can feed recent port names (most-used) for a slight boost
export function searchPorts(query: string, cache: PortEntry[], limit = 10, recentNames?: string[]): PortEntry[] {
  if (!query.trim()) return [];
  const recentSet = new Set((recentNames || []).map(n => normalize(n)).slice(0, 24));
  const pool = [...cache, ...curatedPorts, ...masterPorts];
  const short = query.trim().length <= 3; // for short prefixes, relax constraints
  const isPorty = (s: string) => /\b(port|harbour|harbor|seaport|ferry|terminal|cruise|pier|dock|quay|marina)\b/i.test(s);
  const qNorm = normalize(query);
  const scored = pool.map(p => {
    const base = scoreName(qNorm, p.name);
    const aliasScore = Math.max(0, ...(p.aliases || []).map(a => scoreName(qNorm, a)));
    let raw = Math.max(base, aliasScore);
    const porty = (p.isCruise === true) || isPorty(p.name) || (p.aliases || []).some(a => isPorty(a));
    if (porty) raw += 0.08;
    if (recentSet.has(normalize(p.name))) raw += 0.04; // small recency boost
    // Country / region code inclusion if user typed them
    const regionHint = /,\s*([A-Za-z]{2})(?:,|$)/.exec(query);
    if (regionHint && (p.regionCode || p.country)) {
      const code = regionHint[1].toUpperCase();
      if (p.regionCode === code || p.country === code) raw += 0.05;
    }
    const startsWith = normalize(p.name).startsWith(qNorm) || (p.aliases || []).some(a => normalize(a).startsWith(qNorm));
    return { p, s: Math.min(1, raw), porty, startsWith };
  }).filter(x => {
    if (short) {
      // For very short queries, allow prefix matches even if not yet classified porty
      if (x.startsWith) return true;
    }
    return x.porty && x.s >= (short ? 0.30 : 0.45);
  });
  scored.sort((a, b) => (b.s - a.s));
  // Stable promote prefix matches for short queries
  if (short) {
    scored.sort((a, b) => (Number(b.startsWith) - Number(a.startsWith)) || (b.s - a.s));
  }
  const dedup = new Map<string, PortEntry>();
  for (const { p, s } of scored) {
    const key = normalize(p.name);
    const existing = dedup.get(key);
    if (!existing) {
      dedup.set(key, p);
    } else {
      const existingRich = (existing.regionCode ? 1 : 0) + (existing.country ? 1 : 0);
      const candidateRich = (p.regionCode ? 1 : 0) + (p.country ? 1 : 0);
      if (candidateRich > existingRich && s >= 0.5) {
        dedup.set(key, p);
      }
    }
    if (dedup.size >= limit) break;
  }
  return Array.from(dedup.values());
}

export function resolvePortByName(name: string, cache: PortEntry[]): PortEntry | undefined {
  const q = name.trim();
  if (!q) return undefined;
  // 1) Try direct fuzzy search
  const hits = searchPorts(q, cache, 1);
  if (hits[0]) return hits[0];

  // 2) If the query contains qualifiers like "City, ST, CC", try the primary token before the first comma
  const primary = q.split(',')[0]?.trim();
  if (primary && primary.length >= 2 && primary.toLowerCase() !== q.toLowerCase()) {
    const normPrimary = normalize(primary);

    // 2a) Exact name match in cache
    const exactCache = cache.find(p => normalize(p.name) === normPrimary);
    if (exactCache) return exactCache;

    // 2b) Exact name match in curated
    const exactCurated = curatedPorts.find(p => normalize(p.name) === normPrimary);
    if (exactCurated) return exactCurated;

    // 2c) Alias exact match across cache + curated
    const pool = [...cache, ...curatedPorts];
    const aliasExact = pool.find(p => (p.aliases || []).some(a => normalize(a) === normPrimary));
    if (aliasExact) return aliasExact;

    // 2d) Fuzzy search on the primary token
    const hitsPrimary = searchPorts(primary, cache, 1);
    if (hitsPrimary[0]) return hitsPrimary[0];

    // 2e) Fuzzy with port-like variants to boost likelihood
    const variants = [`${primary} cruise port`, `${primary} port`];
    for (const v of variants) {
      const hv = searchPorts(v, cache, 1);
      if (hv[0]) return hv[0];
    }
  }

  return undefined;
}

export function getCuratedPorts(): PortEntry[] {
  return curatedPorts.slice();
}

// Basic fuzzy matcher: true if similarity is above threshold using same scoring as searchPorts
export function fuzzyMatch(query: string, candidate?: string | null, minScore = 0.7): boolean {
  if (!candidate) return false;
  return scoreName(query, candidate) >= minScore;
}

// Online geocoding fallback using OpenStreetMap Nominatim
export async function searchPortsOnline(query: string, limit = 5): Promise<PortEntry[]> {
  const q = query.trim();
  if (!q) return [];
  try {
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&addressdetails=1&limit=${limit}`;
    const res = await fetch(url, {
      headers: {
        'User-Agent': 'cruise-journal-pro/1.0',
        'Accept-Language': 'en',
      },
    } as any);
    const data = await res.json();
    if (!Array.isArray(data)) return [];
    const out: { e: PortEntry; s: number; porty: boolean }[] = [];
    for (const it of data) {
      const name: string = it?.name || it?.display_name?.split(',')[0] || '';
      const lat = parseFloat(it?.lat);
      const lng = parseFloat(it?.lon);
      const cc: string | undefined = it?.address?.country_code ? String(it.address.country_code).toUpperCase() : undefined;
      const regionCode = deriveRegionCode(it?.address);
      if (!name || !isFinite(lat) || !isFinite(lng)) continue;
      // Restrict to likely port/cruise features only (no land-locked cities)
      const typ = String(it?.type || '');
      const cls = String(it?.class || '');
      const nameLower = name.toLowerCase();
      const isLikelyPortType = /harbour|harbor|port|seaport|ferry_terminal|ferry|pier|dock|quay|marina/i.test(typ) || /waterway|amenity|man_made/i.test(cls);
      const hasCruiseHint = /cruise|terminal|pier|portmiami|canada place|ogden point/i.test(nameLower);
      const isLikelyPort = isLikelyPortType || /harbour|harbor|port|pier|dock|quay/i.test(nameLower);
      if (!isLikelyPort) continue; // skip non-porty results entirely
      const s = scoreName(q, name);
      const isCruise = hasCruiseHint;
      const kind: PortEntry['kind'] = hasCruiseHint ? 'cruise-terminal' : (
        /ferry/i.test(typ) ? 'ferry-terminal' : (/harbour|harbor|port|seaport/i.test(typ) ? 'port' : (/pier|dock|quay/i.test(typ) ? 'pier' : (/marina/i.test(typ) ? 'marina' : 'other')))
      );
      out.push({ e: { name, country: cc, regionCode, lat, lng, source: 'online', kind, isCruise }, s, porty: true });
    }
    // Sort: prefer likely ports, then by score
    out.sort((a, b) => (Number((b.e.isCruise ? 1 : 0) - (a.e.isCruise ? 1 : 0))) || (b.s - a.s));
    // Deduplicate by name+country+region
    const seen = new Set<string>();
    const dedup: PortEntry[] = [];
    for (const { e: p } of out) {
      const key = `${normalize(p.name)}|${p.country || ''}|${p.regionCode || ''}`;
      if (!seen.has(key)) { seen.add(key); dedup.push(p); }
      if (dedup.length >= limit) break;
    }
    return dedup;
  } catch {
    return [];
  }
}

// Google Places fallback (requires EXPO_PUBLIC_GOOGLE_PLACES_KEY). Returns [] if no key.
export async function searchPortsGooglePlaces(query: string, limit = 5): Promise<PortEntry[]> {
  const key = (Platform as any).OS ? (process.env.EXPO_PUBLIC_GOOGLE_PLACES_KEY || '') : '';
  if (!key) return [];
  const q = query.trim();
  if (!q) return [];
  try {
    const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(q)}&key=${key}`;
    const res = await fetch(url);
    const data = await res.json();
    if (!data || !Array.isArray(data.results)) return [];
    const out: PortEntry[] = [];
    for (const r of data.results) {
      const name: string = r.name;
      if (!name) continue;
      const lat = r.geometry?.location?.lat;
      const lng = r.geometry?.location?.lng;
      if (!isFinite(lat) || !isFinite(lng)) continue;
      const nameLower = name.toLowerCase();
      if (!/port|harbor|harbour|pier|dock|quay|marina|cruise|terminal/.test(nameLower)) continue;
      out.push({ name, country: undefined, regionCode: undefined, lat, lng, source: 'online', kind: /cruise|terminal/.test(nameLower) ? 'cruise-terminal' : 'port', isCruise: /cruise|terminal/.test(nameLower) });
      if (out.length >= limit) break;
    }
    return out;
  } catch {
    return [];
  }
}

// Unified search: master+cache+curated first, then Google Places, then Nominatim
export async function unifiedPortSearch(query: string, cache: PortEntry[], desired = 10): Promise<PortEntry[]> {
  await loadMasterPorts(); // ensure master dataset is loaded
  const local = searchPorts(query, cache, desired);
  if (local.length >= desired) return local.slice(0, desired);
  const seen = new Set(local.map(p => normalize(p.name)+ '|' + (p.country||'') + '|' + (p.regionCode||'')));
  const google = await searchPortsGooglePlaces(query, Math.max(0, desired - local.length));
  // persist google results
  if (google.length) { persistOnlinePorts(google).catch(()=>{}); }
  const merged1 = [...local];
  for (const g of google) {
    const key = normalize(g.name)+'|'+(g.country||'')+'|'+(g.regionCode||'');
    if (!seen.has(key)) { merged1.push(g); seen.add(key); }
    if (merged1.length >= desired) return merged1;
  }
  const osm = await searchPortsOnline(query, Math.max(0, desired - merged1.length));
  if (osm.length) { persistOnlinePorts(osm).catch(()=>{}); }
  for (const o of osm) {
    const key = normalize(o.name)+'|'+(o.country||'')+'|'+(o.regionCode||'');
    if (!seen.has(key)) { merged1.push(o); seen.add(key); }
    if (merged1.length >= desired) break;
  }
  return merged1.slice(0, desired);
}

// Best-effort region code extraction from Nominatim address for US/CA
function deriveRegionCode(address: any): string | undefined {
  if (!address) return undefined;
  // Prefer provided state_code if present
  if (address.state_code && typeof address.state_code === 'string') {
    const code = address.state_code.toUpperCase();
    if (code.length <= 3) return code;
  }
  const stateName: string | undefined = address.state || address.region || undefined;
  const cc: string | undefined = address.country_code ? String(address.country_code).toUpperCase() : undefined;
  if (!stateName || !cc) return undefined;
  const name = stateName.toLowerCase();
  if (cc === 'US') {
    const us: Record<string, string> = {
      'alaska': 'AK', 'washington': 'WA', 'florida': 'FL', 'california': 'CA', 'new york': 'NY', 'texas': 'TX',
    };
    return us[name];
  }
  if (cc === 'CA') {
    const ca: Record<string, string> = {
      'british columbia': 'BC', 'alberta': 'AB', 'ontario': 'ON', 'quebec': 'QC', 'nova scotia': 'NS',
    };
    return ca[name];
  }
  return undefined;
}
