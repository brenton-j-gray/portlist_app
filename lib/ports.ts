import AsyncStorage from '@react-native-async-storage/async-storage';

export type PortEntry = {
  name: string;
  country?: string;
  regionCode?: string; // State/Province code, e.g., AK, WA, BC
  lat: number;
  lng: number;
  aliases?: string[];
  source?: 'curated' | 'cache' | 'online';
  // Classification
  kind?: 'cruise-terminal' | 'port' | 'harbor' | 'ferry-terminal' | 'pier' | 'marina' | 'other';
  isCruise?: boolean; // explicitly a cruise port/terminal
};

const PORTS_CACHE_KEY = 'ports_cache_v1';

// Load curated cruise ports from JSON (generated by scripts/fetch-cruise-ports.mjs), with fallback to a small inline seed
let curatedJson: any[] | undefined;
try {
  curatedJson = require('../assets/data/ports.curated.json');
} catch {
  curatedJson = undefined;
}
const curatedFallback: PortEntry[] = [
  { name: 'Seattle', country: 'US', regionCode: 'WA', lat: 47.6062, lng: -122.3321, aliases: ['Pier 91', 'Pier 66', 'Port of Seattle'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Vancouver', country: 'CA', regionCode: 'BC', lat: 49.2827, lng: -123.1207, aliases: ['Canada Place', 'Port of Vancouver'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Ketchikan', country: 'US', regionCode: 'AK', lat: 55.3422, lng: -131.6461, aliases: ['Ketchikan Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Juneau', country: 'US', regionCode: 'AK', lat: 58.3019, lng: -134.4197, aliases: ['Juneau Cruise Ship Terminal', 'Juneau, AK', 'Juneau, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Skagway', country: 'US', regionCode: 'AK', lat: 59.4583, lng: -135.3139, aliases: ['Skagway Cruise Dock', 'Skagway, AK', 'Skagway, Alaska'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Sitka', country: 'US', regionCode: 'AK', lat: 57.0531, lng: -135.3300, aliases: ['Sitka, AK', 'Sitka Alaska', 'Sitka Sound Cruise Terminal'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Icy Strait Point', country: 'US', regionCode: 'AK', lat: 58.2881, lng: -135.4974, aliases: ['Hoonah', 'Hoonah, AK', 'Icy Strait'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Haines', country: 'US', regionCode: 'AK', lat: 59.2358, lng: -135.4450, aliases: ['Haines, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Whittier', country: 'US', regionCode: 'AK', lat: 60.7736, lng: -148.6847, aliases: ['Whittier, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Seward', country: 'US', regionCode: 'AK', lat: 60.1042, lng: -149.4422, aliases: ['Seward, AK'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Victoria', country: 'CA', regionCode: 'BC', lat: 48.4284, lng: -123.3656, aliases: ['Victoria, BC', 'Ogden Point'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Miami', country: 'US', regionCode: 'FL', lat: 25.7743, lng: -80.1903, aliases: ['PortMiami', 'Miami Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Port Canaveral', country: 'US', regionCode: 'FL', lat: 28.4101, lng: -80.6188, aliases: ['Cape Canaveral', 'Canaveral Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Nassau', country: 'BS', lat: 25.0478, lng: -77.3554, aliases: ['Nassau Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
  { name: 'Cozumel', country: 'MX', lat: 20.4230, lng: -86.9223, aliases: ['Cozumel Cruise Port', 'Puerto Maya', 'International Pier'], source: 'curated', kind: 'port', isCruise: true },
];
const curatedPorts: PortEntry[] = Array.isArray(curatedJson) && curatedJson.length > 0 ? curatedJson as PortEntry[] : curatedFallback;

export async function loadPortsCache(): Promise<PortEntry[]> {
  try {
    const raw = await AsyncStorage.getItem(PORTS_CACHE_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw) as PortEntry[];
    return Array.isArray(arr) ? arr : [];
  } catch {
    return [];
  }
}

async function savePortsCache(entries: PortEntry[]): Promise<void> {
  try { await AsyncStorage.setItem(PORTS_CACHE_KEY, JSON.stringify(entries)); } catch {}
}

export async function upsertCachedPort(entry: PortEntry): Promise<void> {
  const list = await loadPortsCache();
  const idx = list.findIndex(p => normalize(p.name) === normalize(entry.name));
  if (idx >= 0) list[idx] = { ...entry, source: 'cache' };
  else list.push({ ...entry, source: 'cache' });
  await savePortsCache(list);
}

function stripDiacritics(s: string): string {
  try { return s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch { return s; }
}
function normalize(s: string): string {
  return stripDiacritics(s).trim().toLowerCase();
}

// Lightweight Jaro-Winkler for better short fuzzy matches (improves e.g. "cozuml" -> "Cozumel")
function jaroWinkler(a: string, b: string): number {
  if (a === b) return 1;
  const al = a.length, bl = b.length;
  if (!al || !bl) return 0;
  const matchDistance = Math.floor(Math.max(al, bl) / 2) - 1;
  const aMatches: boolean[] = new Array(al).fill(false);
  const bMatches: boolean[] = new Array(bl).fill(false);
  let matches = 0;
  for (let i = 0; i < al; i++) {
    const start = Math.max(0, i - matchDistance);
    const end = Math.min(i + matchDistance + 1, bl);
    for (let j = start; j < end; j++) {
      if (bMatches[j]) continue;
      if (a[i] !== b[j]) continue;
      aMatches[i] = true;
      bMatches[j] = true;
      matches++;
      break;
    }
  }
  if (!matches) return 0;
  let t = 0; // transpositions
  let k = 0;
  for (let i = 0; i < al; i++) {
    if (!aMatches[i]) continue;
    while (!bMatches[k]) k++;
    if (a[i] !== b[k]) t++;
    k++;
  }
  t /= 2;
  const m = matches;
  let jaro = (m / al + m / bl + (m - t) / m) / 3;
  // Winkler prefix boost
  let prefix = 0;
  for (let i = 0; i < Math.min(4, al, bl); i++) { if (a[i] === b[i]) prefix++; else break; }
  if (jaro > 0.7 && prefix) jaro = jaro + 0.1 * prefix * (1 - jaro);
  return jaro;
}

function levenshtein(a: string, b: string): number {
  const m = a.length, n = b.length;
  if (m === 0) return n;
  if (n === 0) return m;
  const dp = new Array(n + 1);
  for (let j = 0; j <= n; j++) dp[j] = j;
  for (let i = 1; i <= m; i++) {
    let prev = i - 1;
    dp[0] = i;
    for (let j = 1; j <= n; j++) {
      const temp = dp[j];
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
      prev = temp;
    }
  }
  return dp[n];
}

function scoreName(query: string, candidate: string): number {
  const qRaw = normalize(query);
  const c = normalize(candidate);
  if (!qRaw || !c) return 0;
  if (c === qRaw) return 1.0;
  // Token scoring: sum best token matches normalized by token count
  const tokens = qRaw.split(/[^a-z0-9]+/).filter(Boolean);
  if (tokens.length === 0) return 0;
  let total = 0;
  for (const t of tokens) {
    if (!t) continue;
    if (c === t) { total += 1; continue; }
    if (c.startsWith(t)) { total += 0.95; continue; }
    if (c.includes(t)) { total += 0.85; continue; }
    // Levenshtein similarity fallback
    const dist = levenshtein(t, c);
    const maxLen = Math.max(t.length, c.length) || 1;
    let sim = 1 - dist / maxLen; // 0..1
    // If still low, try Jaro-Winkler which is strong for transpositions / typos
    if (sim < 0.75) {
      const jw = jaroWinkler(t, c);
      sim = Math.max(sim, jw * 0.9);
    }
    total += Math.max(0, sim * 0.8);
  }
  let score = total / tokens.length;
  // Boost if candidate ends with region/country patterns present in query
  const regionPattern = /\b([A-Z]{2})\b/; // simple two-letter code
  const regionMatch = query.match(regionPattern);
  if (regionMatch) {
    const code = regionMatch[1].toLowerCase();
    if (c.includes(code)) score += 0.05;
  }
  return Math.min(1, score);
}

// Optional: external callers can feed recent port names (most-used) for a slight boost
export function searchPorts(query: string, cache: PortEntry[], limit = 10, recentNames?: string[]): PortEntry[] {
  if (!query.trim()) return [];
  const recentSet = new Set((recentNames || []).map(n => normalize(n)).slice(0, 24));
  const pool = [...cache, ...curatedPorts];
  const isPorty = (s: string) => /\b(port|harbour|harbor|seaport|ferry|terminal|cruise|pier|dock|quay|marina)\b/i.test(s);
  const qNorm = normalize(query);
  const scored = pool.map(p => {
    const base = scoreName(qNorm, p.name);
    const aliasScore = Math.max(0, ...(p.aliases || []).map(a => scoreName(qNorm, a)));
    let raw = Math.max(base, aliasScore);
    const porty = (p.isCruise === true) || isPorty(p.name) || (p.aliases || []).some(a => isPorty(a));
    if (porty) raw += 0.08;
    if (recentSet.has(normalize(p.name))) raw += 0.04; // small recency boost
    // Country / region code inclusion if user typed them
    const regionHint = /,\s*([A-Za-z]{2})(?:,|$)/.exec(query);
    if (regionHint && (p.regionCode || p.country)) {
      const code = regionHint[1].toUpperCase();
      if (p.regionCode === code || p.country === code) raw += 0.05;
    }
    return { p, s: Math.min(1, raw), porty };
  }).filter(x => x.porty && x.s >= 0.45); // slightly lower threshold due to refined scoring
  scored.sort((a, b) => (b.s - a.s));
  const dedup = new Map<string, PortEntry>();
  for (const { p, s } of scored) {
    const key = normalize(p.name);
    const existing = dedup.get(key);
    if (!existing) {
      dedup.set(key, p);
    } else {
      const existingRich = (existing.regionCode ? 1 : 0) + (existing.country ? 1 : 0);
      const candidateRich = (p.regionCode ? 1 : 0) + (p.country ? 1 : 0);
      if (candidateRich > existingRich && s >= 0.5) {
        dedup.set(key, p);
      }
    }
    if (dedup.size >= limit) break;
  }
  return Array.from(dedup.values());
}

export function resolvePortByName(name: string, cache: PortEntry[]): PortEntry | undefined {
  const q = name.trim();
  if (!q) return undefined;
  // 1) Try direct fuzzy search
  const hits = searchPorts(q, cache, 1);
  if (hits[0]) return hits[0];

  // 2) If the query contains qualifiers like "City, ST, CC", try the primary token before the first comma
  const primary = q.split(',')[0]?.trim();
  if (primary && primary.length >= 2 && primary.toLowerCase() !== q.toLowerCase()) {
    const normPrimary = normalize(primary);

    // 2a) Exact name match in cache
    const exactCache = cache.find(p => normalize(p.name) === normPrimary);
    if (exactCache) return exactCache;

    // 2b) Exact name match in curated
    const exactCurated = curatedPorts.find(p => normalize(p.name) === normPrimary);
    if (exactCurated) return exactCurated;

    // 2c) Alias exact match across cache + curated
    const pool = [...cache, ...curatedPorts];
    const aliasExact = pool.find(p => (p.aliases || []).some(a => normalize(a) === normPrimary));
    if (aliasExact) return aliasExact;

    // 2d) Fuzzy search on the primary token
    const hitsPrimary = searchPorts(primary, cache, 1);
    if (hitsPrimary[0]) return hitsPrimary[0];

    // 2e) Fuzzy with port-like variants to boost likelihood
    const variants = [`${primary} cruise port`, `${primary} port`];
    for (const v of variants) {
      const hv = searchPorts(v, cache, 1);
      if (hv[0]) return hv[0];
    }
  }

  return undefined;
}

export function getCuratedPorts(): PortEntry[] {
  return curatedPorts.slice();
}

// Basic fuzzy matcher: true if similarity is above threshold using same scoring as searchPorts
export function fuzzyMatch(query: string, candidate?: string | null, minScore = 0.7): boolean {
  if (!candidate) return false;
  return scoreName(query, candidate) >= minScore;
}

// Online geocoding fallback using OpenStreetMap Nominatim
export async function searchPortsOnline(query: string, limit = 5): Promise<PortEntry[]> {
  const q = query.trim();
  if (!q) return [];
  try {
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&addressdetails=1&limit=${limit}`;
    const res = await fetch(url, {
      headers: {
        'User-Agent': 'cruise-journal-pro/1.0',
        'Accept-Language': 'en',
      },
    } as any);
    const data = await res.json();
    if (!Array.isArray(data)) return [];
    const out: { e: PortEntry; s: number; porty: boolean }[] = [];
    for (const it of data) {
      const name: string = it?.name || it?.display_name?.split(',')[0] || '';
      const lat = parseFloat(it?.lat);
      const lng = parseFloat(it?.lon);
      const cc: string | undefined = it?.address?.country_code ? String(it.address.country_code).toUpperCase() : undefined;
      const regionCode = deriveRegionCode(it?.address);
      if (!name || !isFinite(lat) || !isFinite(lng)) continue;
      // Restrict to likely port/cruise features only (no land-locked cities)
      const typ = String(it?.type || '');
      const cls = String(it?.class || '');
      const nameLower = name.toLowerCase();
      const isLikelyPortType = /harbour|harbor|port|seaport|ferry_terminal|ferry|pier|dock|quay|marina/i.test(typ) || /waterway|amenity|man_made/i.test(cls);
      const hasCruiseHint = /cruise|terminal|pier|portmiami|canada place|ogden point/i.test(nameLower);
      const isLikelyPort = isLikelyPortType || /harbour|harbor|port|pier|dock|quay/i.test(nameLower);
      if (!isLikelyPort) continue; // skip non-porty results entirely
      const s = scoreName(q, name);
      const isCruise = hasCruiseHint;
      const kind: PortEntry['kind'] = hasCruiseHint ? 'cruise-terminal' : (
        /ferry/i.test(typ) ? 'ferry-terminal' : (/harbour|harbor|port|seaport/i.test(typ) ? 'port' : (/pier|dock|quay/i.test(typ) ? 'pier' : (/marina/i.test(typ) ? 'marina' : 'other')))
      );
      out.push({ e: { name, country: cc, regionCode, lat, lng, source: 'online', kind, isCruise }, s, porty: true });
    }
    // Sort: prefer likely ports, then by score
    out.sort((a, b) => (Number((b.e.isCruise ? 1 : 0) - (a.e.isCruise ? 1 : 0))) || (b.s - a.s));
    // Deduplicate by name+country+region
    const seen = new Set<string>();
    const dedup: PortEntry[] = [];
    for (const { e: p } of out) {
      const key = `${normalize(p.name)}|${p.country || ''}|${p.regionCode || ''}`;
      if (!seen.has(key)) { seen.add(key); dedup.push(p); }
      if (dedup.length >= limit) break;
    }
    return dedup;
  } catch {
    return [];
  }
}

// Best-effort region code extraction from Nominatim address for US/CA
function deriveRegionCode(address: any): string | undefined {
  if (!address) return undefined;
  // Prefer provided state_code if present
  if (address.state_code && typeof address.state_code === 'string') {
    const code = address.state_code.toUpperCase();
    if (code.length <= 3) return code;
  }
  const stateName: string | undefined = address.state || address.region || undefined;
  const cc: string | undefined = address.country_code ? String(address.country_code).toUpperCase() : undefined;
  if (!stateName || !cc) return undefined;
  const name = stateName.toLowerCase();
  if (cc === 'US') {
    const us: Record<string, string> = {
      'alaska': 'AK', 'washington': 'WA', 'florida': 'FL', 'california': 'CA', 'new york': 'NY', 'texas': 'TX',
    };
    return us[name];
  }
  if (cc === 'CA') {
    const ca: Record<string, string> = {
      'british columbia': 'BC', 'alberta': 'AB', 'ontario': 'ON', 'quebec': 'QC', 'nova scotia': 'NS',
    };
    return ca[name];
  }
  return undefined;
}
