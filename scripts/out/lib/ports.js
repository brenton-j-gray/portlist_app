"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPortsCache = loadPortsCache;
exports.upsertCachedPort = upsertCachedPort;
exports.searchPorts = searchPorts;
exports.resolvePortByName = resolvePortByName;
exports.getCuratedPorts = getCuratedPorts;
exports.fuzzyMatch = fuzzyMatch;
exports.searchPortsOnline = searchPortsOnline;
exports.searchPortsGooglePlaces = searchPortsGooglePlaces;
exports.unifiedPortSearch = unifiedPortSearch;
var async_storage_1 = __importDefault(require("@react-native-async-storage/async-storage"));
var react_native_1 = require("react-native");
var PORTS_CACHE_KEY = 'ports_cache_v1';
// Soft cap for number of cached (network-fetched) port entries to avoid unbounded growth.
// Chosen to be reasonably high while keeping JSON size manageable for AsyncStorage.
var MAX_PORT_CACHE_ENTRIES = 1500;
// Load curated cruise ports from JSON (generated by scripts/fetch-cruise-ports.mjs), with fallback to a small inline seed
var curatedJson;
try {
    curatedJson = require('../assets/data/ports.curated.json');
}
catch (_a) {
    curatedJson = undefined;
}
var curatedFallback = [
    { name: 'Seattle', country: 'US', regionCode: 'WA', lat: 47.6062, lng: -122.3321, aliases: ['Pier 91', 'Pier 66', 'Port of Seattle'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Vancouver', country: 'CA', regionCode: 'BC', lat: 49.2827, lng: -123.1207, aliases: ['Canada Place', 'Port of Vancouver'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Ketchikan', country: 'US', regionCode: 'AK', lat: 55.3422, lng: -131.6461, aliases: ['Ketchikan Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Juneau', country: 'US', regionCode: 'AK', lat: 58.3019, lng: -134.4197, aliases: ['Juneau Cruise Ship Terminal', 'Juneau, AK', 'Juneau, Alaska'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Skagway', country: 'US', regionCode: 'AK', lat: 59.4583, lng: -135.3139, aliases: ['Skagway Cruise Dock', 'Skagway, AK', 'Skagway, Alaska'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Sitka', country: 'US', regionCode: 'AK', lat: 57.0531, lng: -135.3300, aliases: ['Sitka, AK', 'Sitka Alaska', 'Sitka Sound Cruise Terminal'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Icy Strait Point', country: 'US', regionCode: 'AK', lat: 58.2881, lng: -135.4974, aliases: ['Hoonah', 'Hoonah, AK', 'Icy Strait'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Haines', country: 'US', regionCode: 'AK', lat: 59.2358, lng: -135.4450, aliases: ['Haines, AK'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Whittier', country: 'US', regionCode: 'AK', lat: 60.7736, lng: -148.6847, aliases: ['Whittier, AK'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Seward', country: 'US', regionCode: 'AK', lat: 60.1042, lng: -149.4422, aliases: ['Seward, AK'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Victoria', country: 'CA', regionCode: 'BC', lat: 48.4284, lng: -123.3656, aliases: ['Victoria, BC', 'Ogden Point'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Miami', country: 'US', regionCode: 'FL', lat: 25.7743, lng: -80.1903, aliases: ['PortMiami', 'Miami Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Port Canaveral', country: 'US', regionCode: 'FL', lat: 28.4101, lng: -80.6188, aliases: ['Cape Canaveral', 'Canaveral Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Nassau', country: 'BS', lat: 25.0478, lng: -77.3554, aliases: ['Nassau Cruise Port'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Cozumel', country: 'MX', lat: 20.4230, lng: -86.9223, aliases: ['Cozumel Cruise Port', 'Puerto Maya', 'International Pier'], source: 'curated', kind: 'port', isCruise: true },
    // Hawaii (added to ensure availability even if external JSON fails to load)
    { name: 'Honolulu', country: 'US', regionCode: 'HI', lat: 21.3069, lng: -157.8665, aliases: ['Honolulu Harbor', 'Honolulu, HI'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Hilo', country: 'US', regionCode: 'HI', lat: 19.7297, lng: -155.0900, aliases: ['Hilo, HI', 'Port of Hilo'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Kona', country: 'US', regionCode: 'HI', lat: 19.6397, lng: -155.9969, aliases: ['Kailua-Kona', 'Kona Tender'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Lahaina', country: 'US', regionCode: 'HI', lat: 20.8783, lng: -156.6825, aliases: ['Lahaina Tender'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Kahului', country: 'US', regionCode: 'HI', lat: 20.8947, lng: -156.4700, aliases: ['Kahului Harbor', 'Maui'], source: 'curated', kind: 'port', isCruise: true },
    { name: 'Nawiliwili', country: 'US', regionCode: 'HI', lat: 21.9560, lng: -159.3560, aliases: ['Kauai', 'Nawiliwili Harbor'], source: 'curated', kind: 'port', isCruise: true },
];
var curatedPorts = Array.isArray(curatedJson) && curatedJson.length > 0 ? curatedJson : curatedFallback;
// -------- Master Ports Dataset (large) --------
var masterPortsLoaded = false;
var masterPorts = [];
function loadMasterPorts() {
    return __awaiter(this, void 0, void 0, function () {
        var raw;
        return __generator(this, function (_a) {
            if (masterPortsLoaded)
                return [2 /*return*/, masterPorts];
            try {
                raw = require('../cruise_ports_master.json');
                masterPorts = (raw || [])
                    .filter(function (r) { return r && (r.port_name || r.city); })
                    .map(function (r) {
                    var name = r.port_name || r.city || '';
                    var lat = parseFloat(r.latitude);
                    var lng = parseFloat(r.longitude);
                    return {
                        name: name,
                        country: r.country_or_territory || undefined,
                        regionCode: r.region || undefined,
                        lat: isFinite(lat) ? lat : 0,
                        lng: isFinite(lng) ? lng : 0,
                        source: 'curated',
                        kind: /terminal|cruise/i.test(name) ? 'cruise-terminal' : 'port',
                        isCruise: /cruise|terminal/i.test(name)
                    };
                })
                    .filter(function (p) { return p.name && p.lat !== 0 && p.lng !== 0; });
            }
            catch (_b) {
                masterPorts = [];
            }
            finally {
                masterPortsLoaded = true;
            }
            return [2 /*return*/, masterPorts];
        });
    });
}
// Persist online-fetched ports (Google / Nominatim) into local cache & in-memory master list
function persistOnlinePorts(fetched) {
    return __awaiter(this, void 0, void 0, function () {
        var cache, byName, mutated, _loop_1, _i, fetched_1, p, overflow, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!fetched || fetched.length === 0)
                        return [2 /*return*/];
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 5, , 6]);
                    return [4 /*yield*/, loadPortsCache()];
                case 2:
                    cache = _b.sent();
                    byName = new Map(cache.map(function (p) { return [normalize(p.name), p]; }));
                    mutated = false;
                    _loop_1 = function (p) {
                        if (!p.name || !isFinite(p.lat) || !isFinite(p.lng))
                            return "continue";
                        var key = normalize(p.name);
                        if (!byName.has(key)) {
                            var entry = __assign(__assign({}, p), { source: 'cache' });
                            cache.push(entry);
                            byName.set(key, entry);
                            mutated = true;
                        }
                        // also add to masterPorts runtime set for immediate availability
                        var existingMaster = masterPorts.find(function (mp) { return normalize(mp.name) === key; });
                        if (!existingMaster)
                            masterPorts.push(__assign(__assign({}, p), { source: p.source || 'online' }));
                    };
                    for (_i = 0, fetched_1 = fetched; _i < fetched_1.length; _i++) {
                        p = fetched_1[_i];
                        _loop_1(p);
                    }
                    if (!mutated) return [3 /*break*/, 4];
                    // Trim cache if we've exceeded the soft cap (oldest first since we append new entries at end)
                    if (cache.length > MAX_PORT_CACHE_ENTRIES) {
                        overflow = cache.length - MAX_PORT_CACHE_ENTRIES;
                        cache.splice(0, overflow);
                    }
                    return [4 /*yield*/, savePortsCache(cache)];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4: return [3 /*break*/, 6];
                case 5:
                    _a = _b.sent();
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/];
            }
        });
    });
}
function loadPortsCache() {
    return __awaiter(this, void 0, void 0, function () {
        var raw, arr, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, async_storage_1.default.getItem(PORTS_CACHE_KEY)];
                case 1:
                    raw = _b.sent();
                    if (!raw)
                        return [2 /*return*/, []];
                    arr = JSON.parse(raw);
                    return [2 /*return*/, Array.isArray(arr) ? arr : []];
                case 2:
                    _a = _b.sent();
                    return [2 /*return*/, []];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function savePortsCache(entries) {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, async_storage_1.default.setItem(PORTS_CACHE_KEY, JSON.stringify(entries))];
                case 1:
                    _b.sent();
                    return [3 /*break*/, 3];
                case 2:
                    _a = _b.sent();
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function upsertCachedPort(entry) {
    return __awaiter(this, void 0, void 0, function () {
        var list, idx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadPortsCache()];
                case 1:
                    list = _a.sent();
                    idx = list.findIndex(function (p) { return normalize(p.name) === normalize(entry.name); });
                    if (idx >= 0)
                        list[idx] = __assign(__assign({}, entry), { source: 'cache' });
                    else
                        list.push(__assign(__assign({}, entry), { source: 'cache' }));
                    return [4 /*yield*/, savePortsCache(list)];
                case 2:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function stripDiacritics(s) {
    try {
        return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }
    catch (_a) {
        return s;
    }
}
function normalize(s) {
    return stripDiacritics(s).trim().toLowerCase();
}
// Lightweight Jaro-Winkler for better short fuzzy matches (improves e.g. "cozuml" -> "Cozumel")
function jaroWinkler(a, b) {
    if (a === b)
        return 1;
    var al = a.length, bl = b.length;
    if (!al || !bl)
        return 0;
    var matchDistance = Math.floor(Math.max(al, bl) / 2) - 1;
    var aMatches = new Array(al).fill(false);
    var bMatches = new Array(bl).fill(false);
    var matches = 0;
    for (var i = 0; i < al; i++) {
        var start = Math.max(0, i - matchDistance);
        var end = Math.min(i + matchDistance + 1, bl);
        for (var j = start; j < end; j++) {
            if (bMatches[j])
                continue;
            if (a[i] !== b[j])
                continue;
            aMatches[i] = true;
            bMatches[j] = true;
            matches++;
            break;
        }
    }
    if (!matches)
        return 0;
    var t = 0; // transpositions
    var k = 0;
    for (var i = 0; i < al; i++) {
        if (!aMatches[i])
            continue;
        while (!bMatches[k])
            k++;
        if (a[i] !== b[k])
            t++;
        k++;
    }
    t /= 2;
    var m = matches;
    var jaro = (m / al + m / bl + (m - t) / m) / 3;
    // Winkler prefix boost
    var prefix = 0;
    for (var i = 0; i < Math.min(4, al, bl); i++) {
        if (a[i] === b[i])
            prefix++;
        else
            break;
    }
    if (jaro > 0.7 && prefix)
        jaro = jaro + 0.1 * prefix * (1 - jaro);
    return jaro;
}
function levenshtein(a, b) {
    var m = a.length, n = b.length;
    if (m === 0)
        return n;
    if (n === 0)
        return m;
    var dp = new Array(n + 1);
    for (var j = 0; j <= n; j++)
        dp[j] = j;
    for (var i = 1; i <= m; i++) {
        var prev = i - 1;
        dp[0] = i;
        for (var j = 1; j <= n; j++) {
            var temp = dp[j];
            var cost = a[i - 1] === b[j - 1] ? 0 : 1;
            dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
            prev = temp;
        }
    }
    return dp[n];
}
function scoreName(query, candidate) {
    var qRaw = normalize(query);
    var c = normalize(candidate);
    if (!qRaw || !c)
        return 0;
    if (c === qRaw)
        return 1.0;
    // Token scoring: sum best token matches normalized by token count
    var tokens = qRaw.split(/[^a-z0-9]+/).filter(Boolean);
    if (tokens.length === 0)
        return 0;
    var total = 0;
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var t = tokens_1[_i];
        if (!t)
            continue;
        if (c === t) {
            total += 1;
            continue;
        }
        if (c.startsWith(t)) {
            total += 0.95;
            continue;
        }
        // avoid accidental matches on very short tokens (e.g., 'hi' matching 'karachi')
        if (t.length >= 3 && c.includes(t)) {
            total += 0.85;
            continue;
        }
        // Levenshtein similarity fallback
        var dist = levenshtein(t, c);
        var maxLen = Math.max(t.length, c.length) || 1;
        var sim = 1 - dist / maxLen; // 0..1
        // If still low, try Jaro-Winkler which is strong for transpositions / typos
        if (sim < 0.75) {
            var jw = jaroWinkler(t, c);
            sim = Math.max(sim, jw * 0.9);
        }
        total += Math.max(0, sim * 0.8);
    }
    var score = total / tokens.length;
    return Math.min(1, score);
}
// Optional: external callers can feed recent port names (most-used) for a slight boost
function searchPorts(query, cache, limit, recentNames) {
    if (limit === void 0) { limit = 10; }
    if (!query.trim())
        return [];
    var recentSet = new Set((recentNames || []).map(function (n) { return normalize(n); }).slice(0, 24));
    var pool = __spreadArray(__spreadArray(__spreadArray([], cache, true), curatedPorts, true), masterPorts, true);
    var short = query.trim().length <= 3; // for short prefixes, relax constraints
    var isPorty = function (s) { return /\b(port|harbour|harbor|seaport|ferry|terminal|cruise|pier|dock|quay|marina)\b/i.test(s); };
    var qNorm = normalize(query);
    var scored = pool.map(function (p) {
        var base = scoreName(qNorm, p.name);
        var aliasScore = Math.max.apply(Math, __spreadArray([0], (p.aliases || []).map(function (a) { return scoreName(qNorm, a); }), false));
        var raw = Math.max(base, aliasScore);
        var porty = (p.isCruise === true) || isPorty(p.name) || (p.aliases || []).some(function (a) { return isPorty(a); });
        if (porty)
            raw += 0.08;
        if (recentSet.has(normalize(p.name)))
            raw += 0.04; // small recency boost
        // Country / region code inclusion if user typed them
        var regionHint = /,\s*([A-Za-z]{2})(?:,|$)/.exec(query);
        if (regionHint && (p.regionCode || p.country)) {
            var code = regionHint[1].toUpperCase();
            if (p.regionCode === code || p.country === code)
                raw += 0.05;
        }
        var startsWith = normalize(p.name).startsWith(qNorm) || (p.aliases || []).some(function (a) { return normalize(a).startsWith(qNorm); });
        return { p: p, s: Math.min(1, raw), porty: porty, startsWith: startsWith };
    }).filter(function (x) {
        if (short) {
            // For very short queries, allow prefix matches even if not yet classified porty
            if (x.startsWith)
                return true;
        }
        return x.porty && x.s >= (short ? 0.30 : 0.45);
    });
    scored.sort(function (a, b) { return (b.s - a.s); });
    // Stable promote prefix matches for short queries
    if (short) {
        scored.sort(function (a, b) { return (Number(b.startsWith) - Number(a.startsWith)) || (b.s - a.s); });
    }
    var dedup = new Map();
    for (var _i = 0, scored_1 = scored; _i < scored_1.length; _i++) {
        var _a = scored_1[_i], p = _a.p, s = _a.s;
        var key = normalize(p.name);
        var existing = dedup.get(key);
        if (!existing) {
            dedup.set(key, p);
        }
        else {
            var existingRich = (existing.regionCode ? 1 : 0) + (existing.country ? 1 : 0);
            var candidateRich = (p.regionCode ? 1 : 0) + (p.country ? 1 : 0);
            if (candidateRich > existingRich && s >= 0.5) {
                dedup.set(key, p);
            }
        }
        if (dedup.size >= limit)
            break;
    }
    return Array.from(dedup.values());
}
function resolvePortByName(name, cache) {
    var _a;
    var q = name.trim();
    if (!q)
        return undefined;
    // 1) Try direct fuzzy search
    var hits = searchPorts(q, cache, 1);
    if (hits[0])
        return hits[0];
    // 2) If the query contains qualifiers like "City, ST, CC", try the primary token before the first comma
    var primary = (_a = q.split(',')[0]) === null || _a === void 0 ? void 0 : _a.trim();
    if (primary && primary.length >= 2 && primary.toLowerCase() !== q.toLowerCase()) {
        var normPrimary_1 = normalize(primary);
        // 2a) Exact name match in cache
        var exactCache = cache.find(function (p) { return normalize(p.name) === normPrimary_1; });
        if (exactCache)
            return exactCache;
        // 2b) Exact name match in curated
        var exactCurated = curatedPorts.find(function (p) { return normalize(p.name) === normPrimary_1; });
        if (exactCurated)
            return exactCurated;
        // 2c) Alias exact match across cache + curated
        var pool = __spreadArray(__spreadArray([], cache, true), curatedPorts, true);
        var aliasExact = pool.find(function (p) { return (p.aliases || []).some(function (a) { return normalize(a) === normPrimary_1; }); });
        if (aliasExact)
            return aliasExact;
        // 2d) Fuzzy search on the primary token
        var hitsPrimary = searchPorts(primary, cache, 1);
        if (hitsPrimary[0])
            return hitsPrimary[0];
        // 2e) Fuzzy with port-like variants to boost likelihood
        var variants = ["".concat(primary, " cruise port"), "".concat(primary, " port")];
        for (var _i = 0, variants_1 = variants; _i < variants_1.length; _i++) {
            var v = variants_1[_i];
            var hv = searchPorts(v, cache, 1);
            if (hv[0])
                return hv[0];
        }
    }
    return undefined;
}
function getCuratedPorts() {
    return curatedPorts.slice();
}
// Basic fuzzy matcher: true if similarity is above threshold using same scoring as searchPorts
function fuzzyMatch(query, candidate, minScore) {
    if (minScore === void 0) { minScore = 0.7; }
    if (!candidate)
        return false;
    return scoreName(query, candidate) >= minScore;
}
// Online geocoding fallback using OpenStreetMap Nominatim
function searchPortsOnline(query_1) {
    return __awaiter(this, arguments, void 0, function (query, limit) {
        var q, url, res, data, out, _i, data_1, it, name_1, lat, lng, cc, regionCode, typ, cls, nameLower, isLikelyPortType, hasCruiseHint, isLikelyPort, s, isCruise, kind, seen, dedup, _a, out_1, p, key, _b;
        var _c, _d;
        if (limit === void 0) { limit = 5; }
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    q = query.trim();
                    if (!q)
                        return [2 /*return*/, []];
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 4, , 5]);
                    url = "https://nominatim.openstreetmap.org/search?format=jsonv2&q=".concat(encodeURIComponent(q), "&addressdetails=1&limit=").concat(limit);
                    return [4 /*yield*/, fetch(url, {
                            headers: {
                                'User-Agent': 'portlist/1.0',
                                'Accept-Language': 'en',
                            },
                        })];
                case 2:
                    res = _e.sent();
                    return [4 /*yield*/, res.json()];
                case 3:
                    data = _e.sent();
                    if (!Array.isArray(data))
                        return [2 /*return*/, []];
                    out = [];
                    for (_i = 0, data_1 = data; _i < data_1.length; _i++) {
                        it = data_1[_i];
                        name_1 = (it === null || it === void 0 ? void 0 : it.name) || ((_c = it === null || it === void 0 ? void 0 : it.display_name) === null || _c === void 0 ? void 0 : _c.split(',')[0]) || '';
                        lat = parseFloat(it === null || it === void 0 ? void 0 : it.lat);
                        lng = parseFloat(it === null || it === void 0 ? void 0 : it.lon);
                        cc = ((_d = it === null || it === void 0 ? void 0 : it.address) === null || _d === void 0 ? void 0 : _d.country_code) ? String(it.address.country_code).toUpperCase() : undefined;
                        regionCode = deriveRegionCode(it === null || it === void 0 ? void 0 : it.address);
                        if (!name_1 || !isFinite(lat) || !isFinite(lng))
                            continue;
                        typ = String((it === null || it === void 0 ? void 0 : it.type) || '');
                        cls = String((it === null || it === void 0 ? void 0 : it.class) || '');
                        nameLower = name_1.toLowerCase();
                        isLikelyPortType = /harbour|harbor|port|seaport|ferry_terminal|ferry|pier|dock|quay|marina/i.test(typ) || /waterway|amenity|man_made/i.test(cls);
                        hasCruiseHint = /cruise|terminal|pier|portmiami|canada place|ogden point/i.test(nameLower);
                        isLikelyPort = isLikelyPortType || /harbour|harbor|port|pier|dock|quay/i.test(nameLower);
                        if (!isLikelyPort)
                            continue; // skip non-porty results entirely
                        s = scoreName(q, name_1);
                        isCruise = hasCruiseHint;
                        kind = hasCruiseHint ? 'cruise-terminal' : (/ferry/i.test(typ) ? 'ferry-terminal' : (/harbour|harbor|port|seaport/i.test(typ) ? 'port' : (/pier|dock|quay/i.test(typ) ? 'pier' : (/marina/i.test(typ) ? 'marina' : 'other'))));
                        out.push({ e: { name: name_1, country: cc, regionCode: regionCode, lat: lat, lng: lng, source: 'online', kind: kind, isCruise: isCruise }, s: s, porty: true });
                    }
                    // Sort: prefer likely ports, then by score
                    out.sort(function (a, b) { return (Number((b.e.isCruise ? 1 : 0) - (a.e.isCruise ? 1 : 0))) || (b.s - a.s); });
                    seen = new Set();
                    dedup = [];
                    for (_a = 0, out_1 = out; _a < out_1.length; _a++) {
                        p = out_1[_a].e;
                        key = "".concat(normalize(p.name), "|").concat(p.country || '', "|").concat(p.regionCode || '');
                        if (!seen.has(key)) {
                            seen.add(key);
                            dedup.push(p);
                        }
                        if (dedup.length >= limit)
                            break;
                    }
                    return [2 /*return*/, dedup];
                case 4:
                    _b = _e.sent();
                    return [2 /*return*/, []];
                case 5: return [2 /*return*/];
            }
        });
    });
}
// Google Places fallback (requires EXPO_PUBLIC_GOOGLE_PLACES_KEY). Returns [] if no key.
function searchPortsGooglePlaces(query_1) {
    return __awaiter(this, arguments, void 0, function (query, limit) {
        var key, q, url, res, data, out, _i, _a, r, name_2, lat, lng, nameLower, _b;
        var _c, _d, _e, _f;
        if (limit === void 0) { limit = 5; }
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    key = react_native_1.Platform.OS ? (process.env.EXPO_PUBLIC_GOOGLE_PLACES_KEY || '') : '';
                    if (!key)
                        return [2 /*return*/, []];
                    q = query.trim();
                    if (!q)
                        return [2 /*return*/, []];
                    _g.label = 1;
                case 1:
                    _g.trys.push([1, 4, , 5]);
                    url = "https://maps.googleapis.com/maps/api/place/textsearch/json?query=".concat(encodeURIComponent(q), "&key=").concat(key);
                    return [4 /*yield*/, fetch(url)];
                case 2:
                    res = _g.sent();
                    return [4 /*yield*/, res.json()];
                case 3:
                    data = _g.sent();
                    if (!data || !Array.isArray(data.results))
                        return [2 /*return*/, []];
                    out = [];
                    for (_i = 0, _a = data.results; _i < _a.length; _i++) {
                        r = _a[_i];
                        name_2 = r.name;
                        if (!name_2)
                            continue;
                        lat = (_d = (_c = r.geometry) === null || _c === void 0 ? void 0 : _c.location) === null || _d === void 0 ? void 0 : _d.lat;
                        lng = (_f = (_e = r.geometry) === null || _e === void 0 ? void 0 : _e.location) === null || _f === void 0 ? void 0 : _f.lng;
                        if (!isFinite(lat) || !isFinite(lng))
                            continue;
                        nameLower = name_2.toLowerCase();
                        if (!/port|harbor|harbour|pier|dock|quay|marina|cruise|terminal/.test(nameLower))
                            continue;
                        out.push({ name: name_2, country: undefined, regionCode: undefined, lat: lat, lng: lng, source: 'online', kind: /cruise|terminal/.test(nameLower) ? 'cruise-terminal' : 'port', isCruise: /cruise|terminal/.test(nameLower) });
                        if (out.length >= limit)
                            break;
                    }
                    return [2 /*return*/, out];
                case 4:
                    _b = _g.sent();
                    return [2 /*return*/, []];
                case 5: return [2 /*return*/];
            }
        });
    });
}
// Unified search: master+cache+curated first, then Google Places, then Nominatim
function unifiedPortSearch(query_1, cache_1) {
    return __awaiter(this, arguments, void 0, function (query, cache, desired) {
        var local, seen, google, merged1, _i, google_1, g, key, osm, _a, osm_1, o, key;
        if (desired === void 0) { desired = 10; }
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadMasterPorts()];
                case 1:
                    _b.sent(); // ensure master dataset is loaded
                    local = searchPorts(query, cache, desired);
                    if (local.length >= desired)
                        return [2 /*return*/, local.slice(0, desired)];
                    seen = new Set(local.map(function (p) { return normalize(p.name) + '|' + (p.country || '') + '|' + (p.regionCode || ''); }));
                    return [4 /*yield*/, searchPortsGooglePlaces(query, Math.max(0, desired - local.length))];
                case 2:
                    google = _b.sent();
                    // persist google results
                    if (google.length) {
                        persistOnlinePorts(google).catch(function () { });
                    }
                    merged1 = __spreadArray([], local, true);
                    for (_i = 0, google_1 = google; _i < google_1.length; _i++) {
                        g = google_1[_i];
                        key = normalize(g.name) + '|' + (g.country || '') + '|' + (g.regionCode || '');
                        if (!seen.has(key)) {
                            merged1.push(g);
                            seen.add(key);
                        }
                        if (merged1.length >= desired)
                            return [2 /*return*/, merged1];
                    }
                    return [4 /*yield*/, searchPortsOnline(query, Math.max(0, desired - merged1.length))];
                case 3:
                    osm = _b.sent();
                    if (osm.length) {
                        persistOnlinePorts(osm).catch(function () { });
                    }
                    for (_a = 0, osm_1 = osm; _a < osm_1.length; _a++) {
                        o = osm_1[_a];
                        key = normalize(o.name) + '|' + (o.country || '') + '|' + (o.regionCode || '');
                        if (!seen.has(key)) {
                            merged1.push(o);
                            seen.add(key);
                        }
                        if (merged1.length >= desired)
                            break;
                    }
                    return [2 /*return*/, merged1.slice(0, desired)];
            }
        });
    });
}
// Best-effort region code extraction from Nominatim address for US/CA
function deriveRegionCode(address) {
    if (!address)
        return undefined;
    // Prefer provided state_code if present
    if (address.state_code && typeof address.state_code === 'string') {
        var code = address.state_code.toUpperCase();
        if (code.length <= 3)
            return code;
    }
    var stateName = address.state || address.region || undefined;
    var cc = address.country_code ? String(address.country_code).toUpperCase() : undefined;
    if (!stateName || !cc)
        return undefined;
    var name = stateName.toLowerCase();
    if (cc === 'US') {
        var us = {
            'alaska': 'AK', 'washington': 'WA', 'florida': 'FL', 'california': 'CA', 'new york': 'NY', 'texas': 'TX',
        };
        return us[name];
    }
    if (cc === 'CA') {
        var ca = {
            'british columbia': 'BC', 'alberta': 'AB', 'ontario': 'ON', 'quebec': 'QC', 'nova scotia': 'NS',
        };
        return ca[name];
    }
    return undefined;
}
